Username,Repo,Commit,Bug,Code
deepfakes,faceswap,f8c1bf26dfe6cf04e3d328273a48ee4ea71d694e,memory,"@@ -1,18 +1,29 @@
 #!/usr/bin/env python3
 """""" Collects and returns Information on available Apple Silicon SoCs in Apple Macs. """"""
-from typing import List
+from typing import List, Optional
 
-import lib.metal as metal
+import os
+import psutil
+import tensorflow as tf
 
 from lib.utils import FaceswapError
 
 from ._base import GPUStats
 
 
+_METAL_INITIALIZED: bool = False
+
+
 class AppleSiliconStats(GPUStats):
     """""" Holds information and statistics about Apple Silicon SoC(s) available on the currently
     running Apple system.
 
+    Notes
+    -----
+    Apple Silicon is a bit different from other backends, as it does not have a dedicated GPU with
+    it's own dedicated VRAM, rather the RAM is shared with the CPU and GPU. A combination of psutil
+    and Tensorflow are used to pull as much useful information as possible.
+
     Parameters
     ----------
     log: bool, optional
@@ -22,29 +33,68 @@ class AppleSiliconStats(GPUStats):
         available then this parameter should be set to ``False``. Otherwise set to ``True``.
         Default: ``True``
     """"""
+    def __init__(self, log: bool = True) -> None:
+        # Following attribute set in :func:``_initialize``
+        self._tf_devices: Optional(List[str]) = None
+
+        super().__init__(log=log)
 
     def _initialize(self) -> None:
         """""" Initialize Metal for Apple Silicon SoC(s).
 
         If :attr:`_is_initialized` is ``True`` then this function just returns performing no
         action. Otherwise :attr:`is_initialized` is set to ``True`` after successfully
         initializing Metal.
+        """"""
+        if self._is_initialized:
+            return
+        self._log(""debug"", ""Initializing Metal for Apple Silicon SoC."")
+        self._initialize_metal()
+
+        self._tf_devices = tf.config.list_physical_devices(device_type=""GPU"")
+
+        super()._initialize()
+
+    def _initialize_metal(self) -> None:
+        """""" Initialize Metal on first call to this class and set global
+        :attr:``_METAL_INITIALIZED`` to ``True``. If Metal has already been initialized then return
+        performing no action.
+        """"""
+        global _METAL_INITIALIZED  # pylint:disable=global-statement
+
+        if _METAL_INITIALIZED:
+            return
+
+        self._log(""debug"", ""Performing first time Apple SoC setup."")
+
+        os.environ[""DISPLAY""] = "":0""
+
+        try:
+            os.system(""open -a XQuartz"")
+        except Exception as err:  # pylint:disable=broad-except
+            self._log(""debug"", f""Swallowing error opening XQuartz: {str(err)}"")
+
+        self._test_tensorflow()
+
+        _METAL_INITIALIZED = True
+
+    def _test_tensorflow(self) -> None:
+        """""" Test that tensorflow can execute correctly.
 
         Raises
         ------
         FaceswapError
-            If the Metal library could not be successfully loaded
+            If the Tensorflow library could not be successfully initialized
         """"""
-        if self._is_initialized:
-            return
-        self._log(""debug"", ""Initializing Metal for Apple Silicon SoC."")
         try:
-            metal.init()  # pylint:disable=no-member
+            meminfo = tf.config.experimental.get_memory_info('GPU:0')
+            devices = tf.config.list_logical_devices()
+            self._log(""debug"",
+                      f""Tensorflow initialization test: (mem_info: {meminfo}, devices: {devices}"")
         except RuntimeError as err:
-            msg = (""An unhandled exception occured initializing the device via Metal""
+            msg = (""An unhandled exception occured initializing the device via Tensorflow ""
                    f""Library. Original error: {str(err)}"")
             raise FaceswapError(msg) from err
-        super()._initialize()
 
     def _get_device_count(self) -> int:
         """""" Detect the number of SoCs attached to the system.
@@ -54,73 +104,88 @@ def _get_device_count(self) -> int:
         int
             The total number of SoCs available
         """"""
-        retval = metal.get_device_count()  # pylint:disable=no-member
+        retval = len(self._tf_devices)
         self._log(""debug"", f""GPU Device count: {retval}"")
         return retval
 
     def _get_handles(self) -> list:
         """""" Obtain the device handles for all available Apple Silicon SoCs.
 
+        Notes
+        -----
+        Apple SoC does not use handles, so return a list of indices corresponding to found
+        GPU devices
+
         Returns
         -------
         list
-            The list of pointers for available Apple Silicon SoCs
+            The list of indices for available Apple Silicon SoCs
         """"""
-        handles = metal.get_handles()  # pylint:disable=no-member
-        self._log(""debug"", f""GPU Handles found: {len(handles)}"")
+        handles = list(range(self._device_count))
+        self._log(""debug"", f""GPU Handles found: {handles}"")
         return handles
 
     def _get_driver(self) -> str:
         """""" Obtain the Apple Silicon driver version currently in use.
 
+        Notes
+        -----
+        As the SoC is not a discreet GPU it does not technically have a driver version, so just
+        return `'Not Applicable'` as a string
+
         Returns
         -------
         str
             The current SoC driver version
         """"""
-        driver = metal.get_driver_version()  # pylint:disable=no-member
+        driver = ""Not Applicable""
         self._log(""debug"", f""GPU Driver: {driver}"")
         return driver
 
     def _get_device_names(self) -> List[str]:
-        """""" Obtain the list of names of available Apple Silicon SoC(s) as identified in :attr:`_handles`.
+        """""" Obtain the list of names of available Apple Silicon SoC(s) as identified in
+        :attr:`_handles`.
 
         Returns
         -------
         list
             The list of available Apple Silicon SoC names
         """"""
-        names = metal.get_device_names()
+        names = [d.name for d in self._tf_devices]
         self._log(""debug"", f""GPU Devices: {names}"")
         return names
 
     def _get_vram(self) -> List[float]:
         """""" Obtain the VRAM in Megabytes for each available Apple Silicon SoC(s) as identified in
         :attr:`_handles`.
 
+        Notes
+        -----
+        `tf.config.experimental.get_memory_info('GPU:0')` does not work, so uses psutil instead.
+        The total memory on the system is returned as it is shared between the CPU and the GPU.
+        There is no dedicated VRAM.
+
         Returns
         -------
         list
-            The VRAM in Megabytes for each available Apple Silicon SoC
+            The RAM in Megabytes for each available Apple Silicon SoC
         """"""
-        vram = [
-            metal.get_memory_info(i) / (1024 * 1024)
-            for i in range(self._device_count)]
-        self._log(""debug"", f""GPU VRAM: {vram}"")
+        vram = [(psutil.virtual_memory().total / self._device_count) / (1024 * 1024)
+                for _ in range(self._device_count)]
+        self._log(""debug"", f""SoC RAM: {vram}"")
         return vram
 
     def _get_free_vram(self) -> List[float]:
-        """""" Obtain the amount of VRAM that is available, in Megabytes, for each available Apple Silicon
-        SoC.
+        """""" Obtain the amount of VRAM that is available, in Megabytes, for each available Apple
+        Silicon SoC.
 
         Returns
         -------
         list
-             List of `float`s containing the amount of VRAM available, in Megabytes, for each
+             List of `float`s containing the amount of RAM available, in Megabytes, for each
              available SoC as corresponding to the values in :attr:`_handles
         """"""
-        vram = [
-            metal.get_memory_info(i) / (1024 * 1024)
-            for i in range(self._device_count)]
-        self._log(""debug"", f""GPU VRAM free: {vram}"")
+        vram = [(psutil.virtual_memory().available / self._device_count) / (1024 * 1024)
+                for _ in range(self._device_count)]
+        self._log(""debug"", f""SoC RAM free: {vram}"")
         return vram"
deepfakes,faceswap,f8c1bf26dfe6cf04e3d328273a48ee4ea71d694e,memory,"@@ -1,76 +0,0 @@
-from typing import List
-import os
-import psutil  # used for getting GPU memory
-import tensorflow as tf
-
-
-class Constants:
-    class System:
-        ARCH = 'arm64'
-        DEVICE_TYPE = 'GPU'
-        SET_MEMORY_GROWTH = True
-
-    class CUDA:
-        DRIVER_VERSION_UNSUPPORTED = 0
-
-
-def _dbg_check_mem():
-    print(""=========================================="")
-    print(tf.config.experimental.get_memory_info('GPU:0'))
-    print(tf.config.list_logical_devices())
-    print(""=========================================="")
-
-
-def _validate_metal():
-    # Validate a GPU exists
-    assert(len(tf.config.experimental.list_physical_devices('GPU')) > 0)
-
-    # Validate Metal device is working
-    with tf.device('GPU:0'):
-        assert(tf.math.add(1.0, 2.0) == 3.0)
-
-
-def init(device_type: str = 'GPU') -> None:
-    # _validate_metal()
-
-    os.environ['DISPLAY'] = ':0'
-    try:
-        os.system('open -a XQuartz')
-    except Exception:
-        pass
-    Constants.System.DEVICE_TYPE = device_type
-
-    # for device in get_devices():
-    #    tf.config.experimental.set_memory_growth(device, Constants.System.SET_MEMORY_GROWTH)
-
-    _dbg_check_mem()
-
-
-def get_devices() -> List[tf.config.PhysicalDevice]:
-    return tf.config.list_physical_devices(device_type=Constants.System.DEVICE_TYPE)
-
-
-def get_device_count() -> int:
-    return len(get_devices())
-
-
-def get_handles() -> list:
-    return list(range(get_device_count()))
-
-
-def get_driver_version() -> int:
-    # https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART____VERSION.html
-    return Constants.CUDA.DRIVER_VERSION_UNSUPPORTED
-
-
-def get_device_names() -> List[str]:
-    return [d.name for d in get_devices()]
-
-
-def get_memory_info(handle: int) -> int:
-    # Does not work:
-    #   tf.config.experimental.get_memory_info('GPU:0')
-    # So, using psutil instead.
-    # We can just grab the total memory, as it's shared between
-    # the CPU and the GPU. There is no dedicated VRAM.
-    return psutil.virtual_memory().total / get_device_count()"
getsentry,sentry,09d1da50b9ab7f49a1d8b1fe6d86eb00e27b94ec,memory,"@@ -20,6 +20,7 @@
 def resolve_tags(results: Any, query_definition: MetricsQueryBuilder) -> Any:
     """"""Go through the results of a metrics query and reverse resolve its tags""""""
     tags: List[str] = []
+    cached_resolves: Dict[int, str] = {}
 
     with sentry_sdk.start_span(op=""mep"", description=""resolve_tags""):
         for column in query_definition.columns:
@@ -32,7 +33,10 @@ def resolve_tags(results: Any, query_definition: MetricsQueryBuilder) -> Any:
 
         for tag in tags:
             for row in results[""data""]:
-                row[tag] = indexer.reverse_resolve(row[tag])
+                if row[tag] not in cached_resolves:
+                    resolved_tag = indexer.reverse_resolve(row[tag])
+                    cached_resolves[row[tag]] = resolved_tag
+                row[tag] = cached_resolves[row[tag]]
             if tag in results[""meta""]:
                 results[""meta""][tag] = ""string""
 "
deepfakes,faceswap,f8c1bf26dfe6cf04e3d328273a48ee4ea71d694e,memory,"@@ -1,18 +1,29 @@
 #!/usr/bin/env python3
 """""" Collects and returns Information on available Apple Silicon SoCs in Apple Macs. """"""
-from typing import List
+from typing import List, Optional
 
-import lib.metal as metal
+import os
+import psutil
+import tensorflow as tf
 
 from lib.utils import FaceswapError
 
 from ._base import GPUStats
 
 
+_METAL_INITIALIZED: bool = False
+
+
 class AppleSiliconStats(GPUStats):
     """""" Holds information and statistics about Apple Silicon SoC(s) available on the currently
     running Apple system.
 
+    Notes
+    -----
+    Apple Silicon is a bit different from other backends, as it does not have a dedicated GPU with
+    it's own dedicated VRAM, rather the RAM is shared with the CPU and GPU. A combination of psutil
+    and Tensorflow are used to pull as much useful information as possible.
+
     Parameters
     ----------
     log: bool, optional
@@ -22,29 +33,68 @@ class AppleSiliconStats(GPUStats):
         available then this parameter should be set to ``False``. Otherwise set to ``True``.
         Default: ``True``
     """"""
+    def __init__(self, log: bool = True) -> None:
+        # Following attribute set in :func:``_initialize``
+        self._tf_devices: Optional(List[str]) = None
+
+        super().__init__(log=log)
 
     def _initialize(self) -> None:
         """""" Initialize Metal for Apple Silicon SoC(s).
 
         If :attr:`_is_initialized` is ``True`` then this function just returns performing no
         action. Otherwise :attr:`is_initialized` is set to ``True`` after successfully
         initializing Metal.
+        """"""
+        if self._is_initialized:
+            return
+        self._log(""debug"", ""Initializing Metal for Apple Silicon SoC."")
+        self._initialize_metal()
+
+        self._tf_devices = tf.config.list_physical_devices(device_type=""GPU"")
+
+        super()._initialize()
+
+    def _initialize_metal(self) -> None:
+        """""" Initialize Metal on first call to this class and set global
+        :attr:``_METAL_INITIALIZED`` to ``True``. If Metal has already been initialized then return
+        performing no action.
+        """"""
+        global _METAL_INITIALIZED  # pylint:disable=global-statement
+
+        if _METAL_INITIALIZED:
+            return
+
+        self._log(""debug"", ""Performing first time Apple SoC setup."")
+
+        os.environ[""DISPLAY""] = "":0""
+
+        try:
+            os.system(""open -a XQuartz"")
+        except Exception as err:  # pylint:disable=broad-except
+            self._log(""debug"", f""Swallowing error opening XQuartz: {str(err)}"")
+
+        self._test_tensorflow()
+
+        _METAL_INITIALIZED = True
+
+    def _test_tensorflow(self) -> None:
+        """""" Test that tensorflow can execute correctly.
 
         Raises
         ------
         FaceswapError
-            If the Metal library could not be successfully loaded
+            If the Tensorflow library could not be successfully initialized
         """"""
-        if self._is_initialized:
-            return
-        self._log(""debug"", ""Initializing Metal for Apple Silicon SoC."")
         try:
-            metal.init()  # pylint:disable=no-member
+            meminfo = tf.config.experimental.get_memory_info('GPU:0')
+            devices = tf.config.list_logical_devices()
+            self._log(""debug"",
+                      f""Tensorflow initialization test: (mem_info: {meminfo}, devices: {devices}"")
         except RuntimeError as err:
-            msg = (""An unhandled exception occured initializing the device via Metal""
+            msg = (""An unhandled exception occured initializing the device via Tensorflow ""
                    f""Library. Original error: {str(err)}"")
             raise FaceswapError(msg) from err
-        super()._initialize()
 
     def _get_device_count(self) -> int:
         """""" Detect the number of SoCs attached to the system.
@@ -54,73 +104,88 @@ def _get_device_count(self) -> int:
         int
             The total number of SoCs available
         """"""
-        retval = metal.get_device_count()  # pylint:disable=no-member
+        retval = len(self._tf_devices)
         self._log(""debug"", f""GPU Device count: {retval}"")
         return retval
 
     def _get_handles(self) -> list:
         """""" Obtain the device handles for all available Apple Silicon SoCs.
 
+        Notes
+        -----
+        Apple SoC does not use handles, so return a list of indices corresponding to found
+        GPU devices
+
         Returns
         -------
         list
-            The list of pointers for available Apple Silicon SoCs
+            The list of indices for available Apple Silicon SoCs
         """"""
-        handles = metal.get_handles()  # pylint:disable=no-member
-        self._log(""debug"", f""GPU Handles found: {len(handles)}"")
+        handles = list(range(self._device_count))
+        self._log(""debug"", f""GPU Handles found: {handles}"")
         return handles
 
     def _get_driver(self) -> str:
         """""" Obtain the Apple Silicon driver version currently in use.
 
+        Notes
+        -----
+        As the SoC is not a discreet GPU it does not technically have a driver version, so just
+        return `'Not Applicable'` as a string
+
         Returns
         -------
         str
             The current SoC driver version
         """"""
-        driver = metal.get_driver_version()  # pylint:disable=no-member
+        driver = ""Not Applicable""
         self._log(""debug"", f""GPU Driver: {driver}"")
         return driver
 
     def _get_device_names(self) -> List[str]:
-        """""" Obtain the list of names of available Apple Silicon SoC(s) as identified in :attr:`_handles`.
+        """""" Obtain the list of names of available Apple Silicon SoC(s) as identified in
+        :attr:`_handles`.
 
         Returns
         -------
         list
             The list of available Apple Silicon SoC names
         """"""
-        names = metal.get_device_names()
+        names = [d.name for d in self._tf_devices]
         self._log(""debug"", f""GPU Devices: {names}"")
         return names
 
     def _get_vram(self) -> List[float]:
         """""" Obtain the VRAM in Megabytes for each available Apple Silicon SoC(s) as identified in
         :attr:`_handles`.
 
+        Notes
+        -----
+        `tf.config.experimental.get_memory_info('GPU:0')` does not work, so uses psutil instead.
+        The total memory on the system is returned as it is shared between the CPU and the GPU.
+        There is no dedicated VRAM.
+
         Returns
         -------
         list
-            The VRAM in Megabytes for each available Apple Silicon SoC
+            The RAM in Megabytes for each available Apple Silicon SoC
         """"""
-        vram = [
-            metal.get_memory_info(i) / (1024 * 1024)
-            for i in range(self._device_count)]
-        self._log(""debug"", f""GPU VRAM: {vram}"")
+        vram = [(psutil.virtual_memory().total / self._device_count) / (1024 * 1024)
+                for _ in range(self._device_count)]
+        self._log(""debug"", f""SoC RAM: {vram}"")
         return vram
 
     def _get_free_vram(self) -> List[float]:
-        """""" Obtain the amount of VRAM that is available, in Megabytes, for each available Apple Silicon
-        SoC.
+        """""" Obtain the amount of VRAM that is available, in Megabytes, for each available Apple
+        Silicon SoC.
 
         Returns
         -------
         list
-             List of `float`s containing the amount of VRAM available, in Megabytes, for each
+             List of `float`s containing the amount of RAM available, in Megabytes, for each
              available SoC as corresponding to the values in :attr:`_handles
         """"""
-        vram = [
-            metal.get_memory_info(i) / (1024 * 1024)
-            for i in range(self._device_count)]
-        self._log(""debug"", f""GPU VRAM free: {vram}"")
+        vram = [(psutil.virtual_memory().available / self._device_count) / (1024 * 1024)
+                for _ in range(self._device_count)]
+        self._log(""debug"", f""SoC RAM free: {vram}"")
         return vram"
deepfakes,faceswap,f8c1bf26dfe6cf04e3d328273a48ee4ea71d694e,memory,"@@ -1,76 +0,0 @@
-from typing import List
-import os
-import psutil  # used for getting GPU memory
-import tensorflow as tf
-
-
-class Constants:
-    class System:
-        ARCH = 'arm64'
-        DEVICE_TYPE = 'GPU'
-        SET_MEMORY_GROWTH = True
-
-    class CUDA:
-        DRIVER_VERSION_UNSUPPORTED = 0
-
-
-def _dbg_check_mem():
-    print(""=========================================="")
-    print(tf.config.experimental.get_memory_info('GPU:0'))
-    print(tf.config.list_logical_devices())
-    print(""=========================================="")
-
-
-def _validate_metal():
-    # Validate a GPU exists
-    assert(len(tf.config.experimental.list_physical_devices('GPU')) > 0)
-
-    # Validate Metal device is working
-    with tf.device('GPU:0'):
-        assert(tf.math.add(1.0, 2.0) == 3.0)
-
-
-def init(device_type: str = 'GPU') -> None:
-    # _validate_metal()
-
-    os.environ['DISPLAY'] = ':0'
-    try:
-        os.system('open -a XQuartz')
-    except Exception:
-        pass
-    Constants.System.DEVICE_TYPE = device_type
-
-    # for device in get_devices():
-    #    tf.config.experimental.set_memory_growth(device, Constants.System.SET_MEMORY_GROWTH)
-
-    _dbg_check_mem()
-
-
-def get_devices() -> List[tf.config.PhysicalDevice]:
-    return tf.config.list_physical_devices(device_type=Constants.System.DEVICE_TYPE)
-
-
-def get_device_count() -> int:
-    return len(get_devices())
-
-
-def get_handles() -> list:
-    return list(range(get_device_count()))
-
-
-def get_driver_version() -> int:
-    # https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART____VERSION.html
-    return Constants.CUDA.DRIVER_VERSION_UNSUPPORTED
-
-
-def get_device_names() -> List[str]:
-    return [d.name for d in get_devices()]
-
-
-def get_memory_info(handle: int) -> int:
-    # Does not work:
-    #   tf.config.experimental.get_memory_info('GPU:0')
-    # So, using psutil instead.
-    # We can just grab the total memory, as it's shared between
-    # the CPU and the GPU. There is no dedicated VRAM.
-    return psutil.virtual_memory().total / get_device_count()"
getsentry,sentry,09d1da50b9ab7f49a1d8b1fe6d86eb00e27b94ec,memory,"@@ -20,6 +20,7 @@
 def resolve_tags(results: Any, query_definition: MetricsQueryBuilder) -> Any:
     """"""Go through the results of a metrics query and reverse resolve its tags""""""
     tags: List[str] = []
+    cached_resolves: Dict[int, str] = {}
 
     with sentry_sdk.start_span(op=""mep"", description=""resolve_tags""):
         for column in query_definition.columns:
@@ -32,7 +33,10 @@ def resolve_tags(results: Any, query_definition: MetricsQueryBuilder) -> Any:
 
         for tag in tags:
             for row in results[""data""]:
-                row[tag] = indexer.reverse_resolve(row[tag])
+                if row[tag] not in cached_resolves:
+                    resolved_tag = indexer.reverse_resolve(row[tag])
+                    cached_resolves[row[tag]] = resolved_tag
+                row[tag] = cached_resolves[row[tag]]
             if tag in results[""meta""]:
                 results[""meta""][tag] = ""string""
 "
deepfakes,faceswap,f8c1bf26dfe6cf04e3d328273a48ee4ea71d694e,memory,"@@ -1,18 +1,29 @@
 #!/usr/bin/env python3
 """""" Collects and returns Information on available Apple Silicon SoCs in Apple Macs. """"""
-from typing import List
+from typing import List, Optional
 
-import lib.metal as metal
+import os
+import psutil
+import tensorflow as tf
 
 from lib.utils import FaceswapError
 
 from ._base import GPUStats
 
 
+_METAL_INITIALIZED: bool = False
+
+
 class AppleSiliconStats(GPUStats):
     """""" Holds information and statistics about Apple Silicon SoC(s) available on the currently
     running Apple system.
 
+    Notes
+    -----
+    Apple Silicon is a bit different from other backends, as it does not have a dedicated GPU with
+    it's own dedicated VRAM, rather the RAM is shared with the CPU and GPU. A combination of psutil
+    and Tensorflow are used to pull as much useful information as possible.
+
     Parameters
     ----------
     log: bool, optional
@@ -22,29 +33,68 @@ class AppleSiliconStats(GPUStats):
         available then this parameter should be set to ``False``. Otherwise set to ``True``.
         Default: ``True``
     """"""
+    def __init__(self, log: bool = True) -> None:
+        # Following attribute set in :func:``_initialize``
+        self._tf_devices: Optional(List[str]) = None
+
+        super().__init__(log=log)
 
     def _initialize(self) -> None:
         """""" Initialize Metal for Apple Silicon SoC(s).
 
         If :attr:`_is_initialized` is ``True`` then this function just returns performing no
         action. Otherwise :attr:`is_initialized` is set to ``True`` after successfully
         initializing Metal.
+        """"""
+        if self._is_initialized:
+            return
+        self._log(""debug"", ""Initializing Metal for Apple Silicon SoC."")
+        self._initialize_metal()
+
+        self._tf_devices = tf.config.list_physical_devices(device_type=""GPU"")
+
+        super()._initialize()
+
+    def _initialize_metal(self) -> None:
+        """""" Initialize Metal on first call to this class and set global
+        :attr:``_METAL_INITIALIZED`` to ``True``. If Metal has already been initialized then return
+        performing no action.
+        """"""
+        global _METAL_INITIALIZED  # pylint:disable=global-statement
+
+        if _METAL_INITIALIZED:
+            return
+
+        self._log(""debug"", ""Performing first time Apple SoC setup."")
+
+        os.environ[""DISPLAY""] = "":0""
+
+        try:
+            os.system(""open -a XQuartz"")
+        except Exception as err:  # pylint:disable=broad-except
+            self._log(""debug"", f""Swallowing error opening XQuartz: {str(err)}"")
+
+        self._test_tensorflow()
+
+        _METAL_INITIALIZED = True
+
+    def _test_tensorflow(self) -> None:
+        """""" Test that tensorflow can execute correctly.
 
         Raises
         ------
         FaceswapError
-            If the Metal library could not be successfully loaded
+            If the Tensorflow library could not be successfully initialized
         """"""
-        if self._is_initialized:
-            return
-        self._log(""debug"", ""Initializing Metal for Apple Silicon SoC."")
         try:
-            metal.init()  # pylint:disable=no-member
+            meminfo = tf.config.experimental.get_memory_info('GPU:0')
+            devices = tf.config.list_logical_devices()
+            self._log(""debug"",
+                      f""Tensorflow initialization test: (mem_info: {meminfo}, devices: {devices}"")
         except RuntimeError as err:
-            msg = (""An unhandled exception occured initializing the device via Metal""
+            msg = (""An unhandled exception occured initializing the device via Tensorflow ""
                    f""Library. Original error: {str(err)}"")
             raise FaceswapError(msg) from err
-        super()._initialize()
 
     def _get_device_count(self) -> int:
         """""" Detect the number of SoCs attached to the system.
@@ -54,73 +104,88 @@ def _get_device_count(self) -> int:
         int
             The total number of SoCs available
         """"""
-        retval = metal.get_device_count()  # pylint:disable=no-member
+        retval = len(self._tf_devices)
         self._log(""debug"", f""GPU Device count: {retval}"")
         return retval
 
     def _get_handles(self) -> list:
         """""" Obtain the device handles for all available Apple Silicon SoCs.
 
+        Notes
+        -----
+        Apple SoC does not use handles, so return a list of indices corresponding to found
+        GPU devices
+
         Returns
         -------
         list
-            The list of pointers for available Apple Silicon SoCs
+            The list of indices for available Apple Silicon SoCs
         """"""
-        handles = metal.get_handles()  # pylint:disable=no-member
-        self._log(""debug"", f""GPU Handles found: {len(handles)}"")
+        handles = list(range(self._device_count))
+        self._log(""debug"", f""GPU Handles found: {handles}"")
         return handles
 
     def _get_driver(self) -> str:
         """""" Obtain the Apple Silicon driver version currently in use.
 
+        Notes
+        -----
+        As the SoC is not a discreet GPU it does not technically have a driver version, so just
+        return `'Not Applicable'` as a string
+
         Returns
         -------
         str
             The current SoC driver version
         """"""
-        driver = metal.get_driver_version()  # pylint:disable=no-member
+        driver = ""Not Applicable""
         self._log(""debug"", f""GPU Driver: {driver}"")
         return driver
 
     def _get_device_names(self) -> List[str]:
-        """""" Obtain the list of names of available Apple Silicon SoC(s) as identified in :attr:`_handles`.
+        """""" Obtain the list of names of available Apple Silicon SoC(s) as identified in
+        :attr:`_handles`.
 
         Returns
         -------
         list
             The list of available Apple Silicon SoC names
         """"""
-        names = metal.get_device_names()
+        names = [d.name for d in self._tf_devices]
         self._log(""debug"", f""GPU Devices: {names}"")
         return names
 
     def _get_vram(self) -> List[float]:
         """""" Obtain the VRAM in Megabytes for each available Apple Silicon SoC(s) as identified in
         :attr:`_handles`.
 
+        Notes
+        -----
+        `tf.config.experimental.get_memory_info('GPU:0')` does not work, so uses psutil instead.
+        The total memory on the system is returned as it is shared between the CPU and the GPU.
+        There is no dedicated VRAM.
+
         Returns
         -------
         list
-            The VRAM in Megabytes for each available Apple Silicon SoC
+            The RAM in Megabytes for each available Apple Silicon SoC
         """"""
-        vram = [
-            metal.get_memory_info(i) / (1024 * 1024)
-            for i in range(self._device_count)]
-        self._log(""debug"", f""GPU VRAM: {vram}"")
+        vram = [(psutil.virtual_memory().total / self._device_count) / (1024 * 1024)
+                for _ in range(self._device_count)]
+        self._log(""debug"", f""SoC RAM: {vram}"")
         return vram
 
     def _get_free_vram(self) -> List[float]:
-        """""" Obtain the amount of VRAM that is available, in Megabytes, for each available Apple Silicon
-        SoC.
+        """""" Obtain the amount of VRAM that is available, in Megabytes, for each available Apple
+        Silicon SoC.
 
         Returns
         -------
         list
-             List of `float`s containing the amount of VRAM available, in Megabytes, for each
+             List of `float`s containing the amount of RAM available, in Megabytes, for each
              available SoC as corresponding to the values in :attr:`_handles
         """"""
-        vram = [
-            metal.get_memory_info(i) / (1024 * 1024)
-            for i in range(self._device_count)]
-        self._log(""debug"", f""GPU VRAM free: {vram}"")
+        vram = [(psutil.virtual_memory().available / self._device_count) / (1024 * 1024)
+                for _ in range(self._device_count)]
+        self._log(""debug"", f""SoC RAM free: {vram}"")
         return vram"
deepfakes,faceswap,f8c1bf26dfe6cf04e3d328273a48ee4ea71d694e,memory,"@@ -1,76 +0,0 @@
-from typing import List
-import os
-import psutil  # used for getting GPU memory
-import tensorflow as tf
-
-
-class Constants:
-    class System:
-        ARCH = 'arm64'
-        DEVICE_TYPE = 'GPU'
-        SET_MEMORY_GROWTH = True
-
-    class CUDA:
-        DRIVER_VERSION_UNSUPPORTED = 0
-
-
-def _dbg_check_mem():
-    print(""=========================================="")
-    print(tf.config.experimental.get_memory_info('GPU:0'))
-    print(tf.config.list_logical_devices())
-    print(""=========================================="")
-
-
-def _validate_metal():
-    # Validate a GPU exists
-    assert(len(tf.config.experimental.list_physical_devices('GPU')) > 0)
-
-    # Validate Metal device is working
-    with tf.device('GPU:0'):
-        assert(tf.math.add(1.0, 2.0) == 3.0)
-
-
-def init(device_type: str = 'GPU') -> None:
-    # _validate_metal()
-
-    os.environ['DISPLAY'] = ':0'
-    try:
-        os.system('open -a XQuartz')
-    except Exception:
-        pass
-    Constants.System.DEVICE_TYPE = device_type
-
-    # for device in get_devices():
-    #    tf.config.experimental.set_memory_growth(device, Constants.System.SET_MEMORY_GROWTH)
-
-    _dbg_check_mem()
-
-
-def get_devices() -> List[tf.config.PhysicalDevice]:
-    return tf.config.list_physical_devices(device_type=Constants.System.DEVICE_TYPE)
-
-
-def get_device_count() -> int:
-    return len(get_devices())
-
-
-def get_handles() -> list:
-    return list(range(get_device_count()))
-
-
-def get_driver_version() -> int:
-    # https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART____VERSION.html
-    return Constants.CUDA.DRIVER_VERSION_UNSUPPORTED
-
-
-def get_device_names() -> List[str]:
-    return [d.name for d in get_devices()]
-
-
-def get_memory_info(handle: int) -> int:
-    # Does not work:
-    #   tf.config.experimental.get_memory_info('GPU:0')
-    # So, using psutil instead.
-    # We can just grab the total memory, as it's shared between
-    # the CPU and the GPU. There is no dedicated VRAM.
-    return psutil.virtual_memory().total / get_device_count()"
getsentry,sentry,09d1da50b9ab7f49a1d8b1fe6d86eb00e27b94ec,memory,"@@ -20,6 +20,7 @@
 def resolve_tags(results: Any, query_definition: MetricsQueryBuilder) -> Any:
     """"""Go through the results of a metrics query and reverse resolve its tags""""""
     tags: List[str] = []
+    cached_resolves: Dict[int, str] = {}
 
     with sentry_sdk.start_span(op=""mep"", description=""resolve_tags""):
         for column in query_definition.columns:
@@ -32,7 +33,10 @@ def resolve_tags(results: Any, query_definition: MetricsQueryBuilder) -> Any:
 
         for tag in tags:
             for row in results[""data""]:
-                row[tag] = indexer.reverse_resolve(row[tag])
+                if row[tag] not in cached_resolves:
+                    resolved_tag = indexer.reverse_resolve(row[tag])
+                    cached_resolves[row[tag]] = resolved_tag
+                row[tag] = cached_resolves[row[tag]]
             if tag in results[""meta""]:
                 results[""meta""][tag] = ""string""
 "
