Label;Page;Username;Repo;Commit;Bug;Code
KO;1;justlucdewit;cod;958fff8ca320ed225a54ae9fbfef36ef3324eb24;Changed tests to use std/memory.cod;" include ""std/io.cod""
 
 5 malloc"
OK;1;justlucdewit;cod;958fff8ca320ed225a54ae9fbfef36ef3324eb24;Changed tests to use std/memory.cod;"+include ""std/memory.cod""
 include ""std/io.cod""
 
 5 malloc"
KO;1;justlucdewit;cod;958fff8ca320ed225a54ae9fbfef36ef3324eb24;Changed tests to use std/memory.cod;" include ""std/io.cod""
 
 5 malloc"
OK;1;justlucdewit;cod;958fff8ca320ed225a54ae9fbfef36ef3324eb24;Changed tests to use std/memory.cod;"+include ""std/memory.cod""
 include ""std/io.cod""
 
 5 malloc"
KO;1;justlucdewit;cod;958fff8ca320ed225a54ae9fbfef36ef3324eb24;Changed tests to use std/memory.cod;" include ""std/stack.cod""
 include ""std/io.cod""
 include ""std/math.cod"""
OK;1;justlucdewit;cod;958fff8ca320ed225a54ae9fbfef36ef3324eb24;Changed tests to use std/memory.cod;"+include ""std/memory.cod""
 include ""std/stack.cod""
 include ""std/io.cod""
 include ""std/math.cod"""
KO;1;justlucdewit;cod;958fff8ca320ed225a54ae9fbfef36ef3324eb24;Changed tests to use std/memory.cod;" include ""std/stack.cod""
 include ""std/io.cod""
 include ""std/math.cod"""
OK;1;justlucdewit;cod;958fff8ca320ed225a54ae9fbfef36ef3324eb24;Changed tests to use std/memory.cod;"+include ""std/memory.cod""
 include ""std/stack.cod""
 include ""std/io.cod""
 include ""std/math.cod"""
KO;1;justlucdewit;cod;958fff8ca320ed225a54ae9fbfef36ef3324eb24;Changed tests to use std/memory.cod;" include ""std/io.cod""
 include ""std/math.cod""
 "
OK;1;justlucdewit;cod;958fff8ca320ed225a54ae9fbfef36ef3324eb24;Changed tests to use std/memory.cod;"+include ""std/memory.cod""
 include ""std/io.cod""
 include ""std/math.cod""
 "
KO;1;justlucdewit;cod;958fff8ca320ed225a54ae9fbfef36ef3324eb24;Changed tests to use std/memory.cod;" include ""std/stack.cod""
 include ""std/io.cod""
 include ""std/math.cod"""
OK;1;justlucdewit;cod;958fff8ca320ed225a54ae9fbfef36ef3324eb24;Changed tests to use std/memory.cod;"+include ""std/memory.cod""
 include ""std/stack.cod""
 include ""std/io.cod""
 include ""std/math.cod"""
KO;1;justlucdewit;cod;958fff8ca320ed225a54ae9fbfef36ef3324eb24;Changed tests to use std/memory.cod;" include ""std/stack.cod""
 include ""std/io.cod""
 include ""std/cstr.cod"""
OK;1;justlucdewit;cod;958fff8ca320ed225a54ae9fbfef36ef3324eb24;Changed tests to use std/memory.cod;"+include ""std/memory.cod""
 include ""std/stack.cod""
 include ""std/io.cod""
 include ""std/cstr.cod"""
KO;1;justlucdewit;cod;a88f96163ba8b5d00b9d2672bd3986d5cdc4bbf0;Moved memory words to std/memory.cod;"def generate_rt_calls(program, indent_count=1):
             result += f""{indent}stack_push(argc);\n""
         elif part[""type""] == ""argv"":
             result += f""{indent}stack_push((uint64_t)argv);\n""
-        elif part[""type""] == ""malloc"":
-            result += f""{indent}stack_malloc();\n""
-        elif part[""type""] == ""free"":
-            result += f""{indent}stack_free();\n""
-        elif part[""type""] == ""realloc"":
-            result += f""{indent}stack_realloc();\n""
-        elif part[""type""] == ""write8"":
-            result += f""{indent}stack_write8();\n""
-        elif part[""type""] == ""read8"":
-            result += f""{indent}stack_read8();\n""
-        elif part[""type""] == ""read64"":
-            result += f""{indent}stack_read64();\n""
 
         elif part[""type""] == ""parseInt"":
             result += f""{indent}stack_parse_int64();\n"""
OK;1;justlucdewit;cod;a88f96163ba8b5d00b9d2672bd3986d5cdc4bbf0;Moved memory words to std/memory.cod;"def generate_rt_calls(program, indent_count=1):
             result += f""{indent}stack_push(argc);\n""
         elif part[""type""] == ""argv"":
             result += f""{indent}stack_push((uint64_t)argv);\n""
 
         elif part[""type""] == ""parseInt"":
             result += f""{indent}stack_parse_int64();\n"""
KO;1;justlucdewit;cod;a88f96163ba8b5d00b9d2672bd3986d5cdc4bbf0;Moved memory words to std/memory.cod;"def parse_from_words(words, root=False):
     builtin_words = [
         ""argc"",
         ""argv"",
-
-        ""malloc"",
-        ""free"",
-        ""realloc"",
-        ""write8"",
-        ""read8"",
-        ""read64"",
         
         ""parseInt""
     ]"
OK;1;justlucdewit;cod;a88f96163ba8b5d00b9d2672bd3986d5cdc4bbf0;Moved memory words to std/memory.cod;"def parse_from_words(words, root=False):
     builtin_words = [
         ""argc"",
         ""argv"",
         
         ""parseInt""
     ]"
KO;1;justlucdewit;cod;a88f96163ba8b5d00b9d2672bd3986d5cdc4bbf0;Moved memory words to std/memory.cod;\ No newline at end of file
OK;1;justlucdewit;cod;a88f96163ba8b5d00b9d2672bd3986d5cdc4bbf0;Moved memory words to std/memory.cod;"+subroutine malloc {
+    raw ""stack_malloc();""
+}
+
+subroutine free {
+    raw ""stack_free();""
+}
+
+subroutine realloc {
+    raw ""stack_realloc();""
+}
+
+subroutine write8 {
+    raw ""stack_write8();""
+}
+
+subroutine read8 {
+    raw ""stack_read8();""
+}
+
+subroutine read64 {
+    raw ""stack_read64();""
+}
\ No newline at end of file"
KO;1;justlucdewit;cod;a88f96163ba8b5d00b9d2672bd3986d5cdc4bbf0;Moved memory words to std/memory.cod;\ No newline at end of file
OK;1;justlucdewit;cod;a88f96163ba8b5d00b9d2672bd3986d5cdc4bbf0;Moved memory words to std/memory.cod;"+subroutine malloc {
+    raw ""stack_malloc();""
+}
+
+subroutine free {
+    raw ""stack_free();""
+}
+
+subroutine realloc {
+    raw ""stack_realloc();""
+}
+
+subroutine write8 {
+    raw ""stack_write8();""
+}
+
+subroutine read8 {
+    raw ""stack_read8();""
+}
+
+subroutine read64 {
+    raw ""stack_read64();""
+}
\ No newline at end of file"
KO;10;Lincoln-LM;py-gdb-nx;4be70bb77e14d9b8c0443485c25fa5cd5c5880c9;Create methods for reading and writing memory;" """"""Wrapper around pygdbmi.GdbController for easier switch connection""""""
 
 from typing import Optional,List
 import os.path
 import pygdbmi.gdbcontroller
@@ -88,7 +89,8 @@ def attach(
         self,
         process_name: str = ""Application"",
     ):
-        """"""Attach to process of name process_name
 
         Args:
             process_name (str, optional): Name of switch process to attach to.
@@ -120,11 +122,197 @@ def get_bases(
                 self.main_base, self.main_max = \
                     (int(num, 16) for num in line['payload'].replace("" -"","""")[:-2].split("" "")[2:4])
 
     def add_breakpoint(
         self,
         bkpt: Breakpoint,
     ):
-        """"""Activate breakpoint
 
         Args:
             bkpt (Breakpoint): Breakpoint object to activate
@@ -178,7 +366,8 @@ def wait_for_response(
         self,
         target_type: Optional[str] = ""console"",
     ) -> List[dict]:
-        """"""Wait until response from gdb of type target_type
 
         Args:
             target_type (Optional[str], optional): mi3 type to wait for. Defaults to ""console"".
@@ -200,7 +389,8 @@ def log_response(
         response: List[dict],
         detailed: Optional[bool] = False,
     ):
-        """"""Log a mi3 response List[dict]
 
         Args:
             response (List[dict]): mi3 response to log
@@ -233,7 +423,8 @@ def filter_response(
     def extract_payloads(
         response: List[dict],
     ) -> List[str]:
-        """"""Extract only the payloads of a mi3 response
 
         Args:
             response (List[dict]): mi3 response to extract from"
OK;10;Lincoln-LM;py-gdb-nx;4be70bb77e14d9b8c0443485c25fa5cd5c5880c9;Create methods for reading and writing memory;" """"""Wrapper around pygdbmi.GdbController for easier switch connection""""""
 
+import struct
 from typing import Optional,List
 import os.path
 import pygdbmi.gdbcontroller
@@ -88,7 +89,8 @@ def attach(
         self,
         process_name: str = ""Application"",
     ):
+        """"""
+        Attach to process of name process_name
 
         Args:
             process_name (str, optional): Name of switch process to attach to.
@@ -120,11 +122,197 @@ def get_bases(
                 self.main_base, self.main_max = \
                     (int(num, 16) for num in line['payload'].replace("" -"","""")[:-2].split("" "")[2:4])
 
+    def read_instruction(
+        self,
+        address: int,
+        offset_main: Optional[bool] = False,
+        offset_heap: Optional[bool] = False,
+    ) -> str:
+        """"""
+        Read instruction from address
+
+        Args:
+            address (int): Address to read from
+            offset_main (bool, optional): Whether or not to offset address by
+            self.main_base. Defaults to False
+            offset_heap (bool, optional): Whether or not to offset address by
+            self.heap_base. Defaults to False
+
+        Returns:
+            str: Instruction information
+        """"""
+        if offset_main:
+            address += self.main_base
+        elif offset_heap:
+            address += self.heap_base
+        self.write(f""x/1iw {address}"", read_response = False)
+        return self.filter_response(
+            self.get_gdb_response(),
+            ""console""
+            )[0]['payload'].split("":"")[1].replace(""\\t"",""\t"").replace(""\\n"","""")
+
+    def read_int(
+        self,
+        address: int,
+        size: str = ""g"",
+        offset_main: Optional[bool] = False,
+        offset_heap: Optional[bool] = False,
+    ) -> int:
+        """"""
+        Read memory at address
+
+        Args:
+            address (int): Address to read from
+            size (str, optional): GDB size of int to read. Defaults to ""g""
+            offset_main (bool, optional): Whether or not to offset address by
+            self.main_base. Defaults to False
+            offset_heap (bool, optional): Whether or not to offset address by
+            self.heap_base. Defaults to False
+
+        Returns:
+            int: Integer read from address
+        """"""
+        if offset_main:
+            address += self.main_base
+        elif offset_heap:
+            address += self.heap_base
+        self.write(f""x/1x{size} {address}"", read_response = False)
+        return int(self.filter_response(
+            self.get_gdb_response(),
+            ""console""
+            )[0]['payload'].split(""0x"")[-1][:-2].replace("":"",""""),16)
+
+    def read_bytes(
+        self,
+        address: int,
+        size: str = ""g"",
+        offset_main: Optional[bool] = False,
+        offset_heap: Optional[bool] = False,
+    ) -> bytes:
+        """"""
+        Read memory at address and convert it to bytes
+
+        Args:
+            address (int): Address to read from
+            size (str, optional): GDB size of int to read. Defaults to ""g""
+            offset_main (bool, optional): Whether or not to offset address by
+            self.main_base. Defaults to False
+            offset_heap (bool, optional): Whether or not to offset address by
+            self.heap_base. Defaults to False
+
+        Returns:
+            bytes: Bytes read from address
+        """"""
+        if size == ""b"":
+            struct_size = ""B""
+        elif size == ""h"":
+            struct_size = ""H""
+        elif size == ""w"":
+            struct_size = ""I""
+        elif size == ""g"":
+            struct_size = ""Q""
+        return struct.pack(struct_size, self.read_int(address, size, offset_main, offset_heap))
+
+    def read_float(
+        self,
+        address: int,
+        offset_main: Optional[bool] = False,
+        offset_heap: Optional[bool] = False,
+    ) -> float:
+        """"""
+        Read float at address
+
+        Args:
+            address (int): Address to read from
+            offset_main (bool, optional): Whether or not to offset address by
+            self.main_base. Defaults to False
+            offset_heap (bool, optional): Whether or not to offset address by
+            self.heap_base. Defaults to False
+        """"""
+        return struct.unpack(""f"", self.read_bytes(address, ""w"", offset_main, offset_heap))
+
+    def write_int(
+        self,
+        address: int,
+        value: int,
+        size: str = ""g"",
+        offset_main: Optional[bool] = False,
+        offset_heap: Optional[bool] = False,
+    ):
+        """"""
+        Write integer of size to address
+
+        Args:
+            address (int): Address to write to
+            value (int): Value to write to memory
+            size (str, optional): GDB size of int to write. Defaults to ""g""
+            offset_main (bool, optional): Whether or not to offset address by
+            self.main_base. Defaults to False
+            offset_heap (bool, optional): Whether or not to offset address by
+            self.heap_base. Defaults to False
+        """"""
+        if size == ""b"":
+            size = ""unsigned char""
+        elif size == ""h"":
+            size = ""unsigned short""
+        elif size == ""w"":
+            size = ""unsigned word""
+        elif size == ""g"":
+            size = ""unsigned long""
+        if offset_main:
+            address += self.main_base
+        elif offset_heap:
+            address += self.heap_base
+        self.write(f""set {{{size}}}{address} = {value}"")
+
+    def write_bytes(
+        self,
+        address: int,
+        value: bytes,
+        size: str = ""g"",
+        offset_main: Optional[bool] = False,
+        offset_heap: Optional[bool] = False,
+    ):
+        """"""
+        Write bytes of size to address
+
+        Args:
+            address (int): Address to write to
+            value (bytes): Value to write to memory
+            size (str, optional): GDB size of bytes to write. Defaults to ""g""
+            offset_main (bool, optional): Whether or not to offset address by
+            self.main_base. Defaults to False
+            offset_heap (bool, optional): Whether or not to offset address by
+            self.heap_base. Defaults to False
+        """"""
+        self.write_int(address, struct.unpack(""I"", value), size, offset_main, offset_heap)
+
+    def write_float(
+        self,
+        address: int,
+        value: float,
+        offset_main: Optional[bool] = False,
+        offset_heap: Optional[bool] = False,
+    ):
+        """"""
+        Write float to address
+
+        Args:
+            address (int): Address to write to
+            value (float): Value to write to memory
+            offset_main (bool, optional): Whether or not to offset address
+            by self.main_base. Defaults to False
+            offset_heap (bool, optional): Whether or not to offset address
+            by self.heap_base. Defaults to False
+        """"""
+        self.write_bytes(address, struct.pack(""f"", value), ""w"", offset_main, offset_heap)
+
     def add_breakpoint(
         self,
         bkpt: Breakpoint,
     ):
+        """"""
+        Activate breakpoint
 
         Args:
             bkpt (Breakpoint): Breakpoint object to activate
@@ -178,7 +366,8 @@ def wait_for_response(
         self,
         target_type: Optional[str] = ""console"",
     ) -> List[dict]:
+        """"""
+        Wait until response from gdb of type target_type
 
         Args:
             target_type (Optional[str], optional): mi3 type to wait for. Defaults to ""console"".
@@ -200,7 +389,8 @@ def log_response(
         response: List[dict],
         detailed: Optional[bool] = False,
     ):
+        """"""
+        Log a mi3 response List[dict]
 
         Args:
             response (List[dict]): mi3 response to log
@@ -233,7 +423,8 @@ def filter_response(
     def extract_payloads(
         response: List[dict],
     ) -> List[str]:
+        """"""
+        Extract only the payloads of a mi3 response
 
         Args:
             response (List[dict]): mi3 response to extract from"
KO;10;Lincoln-LM;py-gdb-nx;8fa4ecdd069e327eeee3aa01a81aab9b0ba07c01;Attach to process and read bases of memory regions;"def __init__(
         self.ip_address = ip_address
         self.active_breakpoints = {}
         self.main_base: int = None
         self.heap_base: int = None
         self.clear_responses()
         self.connect()
 
     def clear_responses(
         self,
@@ -59,6 +66,42 @@ def connect(
         self.write(f""target extended-remote {self.ip_address}:22225"", read_response=False)
         self.log_response(self.wait_for_response())
 
     def wait_for_response(
         self,
         target_type: Optional[str] = ""console"",
@@ -94,7 +137,7 @@ def log_response(
         if detailed:
             print(response)
         else:
-            for line in self.extract_payloads(response):
                 print(line)
 
     @staticmethod"
OK;10;Lincoln-LM;py-gdb-nx;8fa4ecdd069e327eeee3aa01a81aab9b0ba07c01;Attach to process and read bases of memory regions;"def __init__(
         self.ip_address = ip_address
         self.active_breakpoints = {}
         self.main_base: int = None
+        self.main_max: int = None
         self.heap_base: int = None
+        self.heap_max: int = None
+        self.stack_base: int = None
+        self.stack_max: int = None
         self.clear_responses()
         self.connect()
+        self.attach()
+        self.get_bases()
+        self.write(""set step-mode on"")
 
     def clear_responses(
         self,
@@ -59,6 +66,42 @@ def connect(
         self.write(f""target extended-remote {self.ip_address}:22225"", read_response=False)
         self.log_response(self.wait_for_response())
 
+    def attach(
+        self,
+        process_name: str = ""Application"",
+    ):
+        """"""Attach to process of name process_name
+
+        Args:
+            process_name (str, optional): Name of switch process to attach to.
+            Defaults to ""Application"".
+        """"""
+        self.write(""info os processes"", read_response = False)
+        processes = self.wait_for_response()
+        for line in reversed(processes): # sort by latest process started
+            if line['type'] == ""console"" and process_name in line[""payload""]:
+                process_id = int(line[""payload""].split("" "",1)[0])
+                self.log_response(self.write(f""attach {process_id}""))
+                break
+
+    def get_bases(
+        self,
+    ):
+        """"""
+        Read the base addresses of sections of the switch's memory
+        """"""
+        self.write(""monitor get base"", read_response = False)
+        for line in self.filter_response(self.wait_for_response(""target""), ""target""):
+            if ""Heap"" in line['payload']:
+                self.heap_base, self.heap_max = \
+                    (int(num, 16) for num in line['payload'].replace("" -"","""")[:-2].split("" "")[4:6])
+            elif ""Stack"" in line['payload']:
+                self.stack_base, self.stack_max = \
+                    (int(num, 16) for num in line['payload'].replace("" -"","""")[:-2].split("" "")[3:5])
+            elif "".nss"" in line['payload']:
+                self.main_base, self.main_max = \
+                    (int(num, 16) for num in line['payload'].replace("" -"","""")[:-2].split("" "")[2:4])   
+
     def wait_for_response(
         self,
         target_type: Optional[str] = ""console"",
@@ -94,7 +137,7 @@ def log_response(
         if detailed:
             print(response)
         else:
+            for line in self.extract_payloads(self.filter_response(response)):
                 print(line)
 
     @staticmethod"
KO;22;DeinyRhed;CMSC-123--Memory-Management-and-Allocation-Strategies;c088a95eefd69a2d9be7406e8044da991debe329;Update memory_allocation_strategies.py;"def updateTime(self):
         if self.__jobTime <= 0:
             self.__jobTime = 0
 
-
-
-            
 
 class MemoryBlock:
     def __init__(self, memoryBlock, memorySize):
@@ -48,17 +46,14 @@ def __init__(self, memory:[MemoryBlock], job:[JobInfo]):
         self.__job = job
         self.__allocation = {}  # ({memory : job})
         self.__jobCount = 0     # For the total assigned jobs
-        self.__totalTime = 0
         self.__timer = 1        # For the time
         self.__sumIF = {}       # Total Internal Fragmentation per block ({ memory : job })
         self.__sumBlock = 0  
         self.__totalHUP = {}    # Total Heavily Used Partition ({ memoryBlock : jobSize })
         self.__totalUP = {}     # Total Unused Partition ({ memoryBlock : differenceSize})
        
-    def totalTime(self):
-        for job in self.__job:
-            self.__totalTime += job.jobTime()
-        return self.__totalTime
     
     # This is for the internal fragmentation portion
     def sumIF(self, memory:MemoryBlock, job:JobInfo):
@@ -99,8 +94,12 @@ def firstFit(self):
                         self.__allocation.update({memory : job})
                         self.sumIF(memory,job)
                         self.__jobCount += 1
-                        print(f'Job {str(job.jobStream())}: {str(job.jobSize())} has been allocated in memory block {str(memory.memoryBlock())}:{str(memory.memorySize())} and will reside for {str(job.jobTime())} ms') 
                         break
                     
         
         while len(tempList) -1 >= 2:
@@ -113,7 +112,6 @@ def firstFit(self):
                     job.updateTime()
                     if job.jobTime() > 0:
                         self.__jobCount += 1
-                        print(f'Job {str(job.jobStream())} : {str(job.jobSize())} has been allocated in memory block {str(memory.memoryBlock())}:{str(memory.memorySize())} and will reside for {str(job.jobTime())} ms')
                     # If time == 1, then remove it from the jobList named tempList
                     # Also remove the value from the self.__allocation dictionary
                     else:
@@ -128,18 +126,23 @@ def firstFit(self):
                                     self.__allocation.update({memory : job2})
                                     self.sumIF(memory,job2)
                                     self.__jobCount += 1
-                                    print(f'Job {str(job2.jobStream())} : {str(job.jobSize())} has been allocated in memory block {str(memory.memoryBlock())}:{str(memory.memorySize())} and will reside for {str(job2.jobTime())} ms')
                                     break
                 else:
                     continue
         self.status()
             
     
     def status(self):
         print(f'\n===================================== FIRST FIT ===================================== ')
         print(f'AVERAGE THROUGHPUT (TOTAL ASSIGNED JOB COUNT/ TOTAL TIME: {str(round(self.__jobCount/self.__timer, 2))} jobs per unit of time')
         print(f'AVERAGE WAITING QUEUE (TOTAL WQ LENGTH/ TOTAL TIME: {str(round(self.__totalTime/self.__timer,2))} jobs per unit of time')
-        print(f'AVERAGE WAITING TIME (TOTAL WT/ #JOBS: {str(round(self.totalTime()/len(self.__job),2))} jobs per unit of time\n')
         print(f'TOTAL UNUSED PARTITION ((TOTAL USED MEMORY / 50000) * 100): {str(round(((sum(self.__totalUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity')
         print(f'TOTAL HEAVILY USED PARTITION ((TOTAL EXHAUSTED MEMORY / 50000) * 100): {str(round(((sum(self.__totalHUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity\n')
         print(f'----------------------------- INTERNAL FRAGMENTATION -----------------------------')
@@ -159,20 +162,13 @@ def __init__(self, memory:[MemoryBlock], job:[JobInfo]):
         self.__job = job
         self.__allocation = {}  # ({job : memory})
         self.__jobCount = 0     # For the total assigned jobs
-        self.__totalTime = 0
         self.__timer = 1        # For the timer
         self.__sumBlock = 0
         self.__sumIF = {}       # Total Internal Fragmentation per block ({ memory : diffSize })
-        self.__sumBlock = 0  
         self.__totalHUP = {}    # Total Heavily Used Partition ({ memoryBlock : jobSize })
         self.__totalUP = {}     # Total Unused Partition ({ memoryBlock : differenceSize})
         self.__totalWT = 0
-        self.__totalWQ = {}
-       
-    def totalTime(self):
-        for job in self.__job:
-            self.__totalTime += job.jobTime()
-        return self.__totalTime
     
     
     def sumIF(self, memory:MemoryBlock, job:JobInfo):
@@ -182,7 +178,6 @@ def sumIF(self, memory:MemoryBlock, job:JobInfo):
             self.__sumIF.update({memory.memoryBlock() : [self.__sumBlock]}) # value is a list because we are storing the job and memory size difference in that block
             self.__totalHUP.update({memory.memoryBlock() : job.jobSize()})
             self.__totalUP.update({memory.memoryBlock() : self.__sumBlock})
-            self.__totalWQ.update({memory.memoryBlock() : job.jobTime()})
             
         else:
             temp = (memory.memorySize() - job.jobSize())
@@ -214,7 +209,7 @@ def bestFit(self):
 
         for key,value in self.__allocation.items():
             self.__totalWT += key.jobTime()
-            print(f'Job {str(key.jobStream())}:{str(key.jobSize())} has been allocated in memory block {str(value.memoryBlock())}:{str(value.memorySize())} and will reside for {str(key.jobTime())} ms')
             self.sumIF(value,key)   # key = job and value = memory
             
         self.__jobCount += len(self.__allocation)
@@ -252,7 +247,7 @@ def bestFit(self):
 
             for key,value in self.__allocation.items():
                 self.__totalWT += key.jobTime()
-                print(f'Job {str(key.jobStream())}:{str(key.jobSize())} has been allocated in memory block {str(value.memoryBlock())}:{str(value.memorySize())} and will reside for {str(key.jobTime())} ms')
                 self.sumIF(value,key)
 
         self.status()
@@ -261,8 +256,8 @@ def bestFit(self):
     def status(self):
         print(f'\n===================================== BEST FIT ===================================== ')
         print(f'AVERAGE THROUGHPUT (TOTAL ASSIGNED JOB COUNT/ TOTAL TIME: {str(round(self.__jobCount/self.__timer, 2))} jobs per unit of time')
-        print(f'AVERAGE WAITING QUEUE (TOTAL WQ LENGTH/ TOTAL TIME: {str(self.__jobCount/self.__timer)} jobs per unit of time')
-        print(f'AVERAGE WAITING TIME (TOTAL WT/ #JOBS: {str(round(self.totalTime()/self.__timer,2))} jobs per unit of time\n')
         print(f'TOTAL UNUSED PARTITION ((TOTAL USED MEMORY / 50000) * 100): {str(round(((sum(self.__totalUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity')
         print(f'TOTAL HEAVILY USED PARTITION ((TOTAL EXHAUSTED MEMORY / 50000) * 100): {str(round(((sum(self.__totalHUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity\n')
         print(f'----------------------------- INTERNAL FRAGMENTATION -----------------------------')
@@ -272,7 +267,6 @@ def status(self):
             print(f'Block {str(memory.memoryBlock())}\'s total internal fragmentation (sum[block.size - job.size]): {str((sum(self.__sumIF[memory.memoryBlock()])))} units of memory')
             print(f'Block {str(memory.memoryBlock())}\'s average internal fragmentation (sum / totalTime): {str(round(sum(self.__sumIF[memory.memoryBlock()])/self.__timer, 2 ))} units of memory per unit of time\n')
 
-        print(self.__totalWT)
 
 
 # Worst Fit Memory Allocation
@@ -283,25 +277,25 @@ def __init__(self, memory:[MemoryBlock], job:[JobInfo]):
         self.__job = job
         self.__allocation = {}  # ({job : memory})
         self.__jobCount = 0     # For the total assigned jobs
-        self.__totalTime = len(self.__job)
         self.__timer = 1        # For the timer
         self.__sumBlock = 0
         self.__sumIF = {}       # Total Internal Fragmentation per block ({ memory : diffSize })
         self.__sumBlock = 0  
         self.__totalHUP = {}    # Total Heavily Used Partition ({ memoryBlock : jobSize })
         self.__totalUP = {}     # Total Unused Partition ({ memoryBlock : differenceSize})
         self.__totalWT = 0
-        self.__totalWQ = {}
-    
-    
     def sumIF(self, memory:MemoryBlock, job:JobInfo):
         self.__sumBlock = 0
         if memory.memoryBlock() not in self.__sumIF:
             self.__sumBlock = (memory.memorySize() - job.jobSize()) + self.__sumBlock
             self.__sumIF.update({memory.memoryBlock() : [self.__sumBlock]})
             self.__totalHUP.update({memory.memoryBlock() : job.jobSize()})
             self.__totalUP.update({memory.memoryBlock() : self.__sumBlock})
-            self.__totalWQ.update({memory.memoryBlock() : job.jobTime()})
             
         else:
             temp = (memory.memorySize() - job.jobSize())
@@ -332,13 +326,12 @@ def worstFit(self):
                             worstBlock = 0
                     else:
                         worstBlock = diffSize
-
             
         for key,value in self.__allocation.items():
             self.__totalWT += key.jobTime()
-            print(f'Job {str(key.jobStream())}:{str(key.jobSize())} has been allocated in memory block {str(value.memoryBlock())}:{str(value.memorySize())} and will reside for {str(key.jobTime())} ms')
-            self.sumIF(value,key)        
-        
         while len(self.__allocation) >= 1:
             if len(self.__allocation) == 1 and list(self.__allocation.keys())[0].jobTime() - 1 == 0:
                 break  
@@ -373,7 +366,7 @@ def worstFit(self):
             for key,value in self.__allocation.items():
                 self.sumIF(memory,job)
                 self.__totalWT += key.jobTime()
-                print(f'Job {str(key.jobStream())}:{str(key.jobSize())} has been allocated in memory block {str(value.memoryBlock())}:{str(value.memorySize())} and will reside for {str(key.jobTime())} ms')
             
 
         self.status()
@@ -382,8 +375,8 @@ def worstFit(self):
     def status(self):
         print(f'\n===================================== WORST FIT ===================================== ')
         print(f'AVERAGE THROUGHPUT (TOTAL ASSIGNED JOB COUNT/ TOTAL TIME: {str(round(self.__jobCount/self.__timer, 2))} jobs per unit of time')
-        print(f'AVERAGE WAITING QUEUE (TOTAL WQ LENGTH/ TOTAL TIME: {str(round(self.totalTime()/self.__timer,2))} jobs per unit of time')
-        print(f'AVERAGE WAITING TIME (TOTAL WT/ #JOBS): {str(round(self.totalTime()/len(self.__job),2))} jobs per unit of time')
         print(f'TOTAL UNUSED PARTITION ((TOTAL USED MEMORY / 50000) * 100): {str(round(((sum(self.__totalUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity')
         print(f'TOTAL HEAVILY USED PARTITION ((TOTAL EXHAUSTED MEMORY / 50000) * 100): {str(round(((sum(self.__totalHUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity\n')
         print(f'----------------------------- INTERNAL FRAGMENTATION -----------------------------')
@@ -395,12 +388,11 @@ def status(self):
                 print(f'Block {str(memory.memoryBlock())}\'s average internal fragmentation (sum / totalTime): {str(round(sum(self.__sumIF[memory.memoryBlock()])/self.__timer, 2 ))} units of memory per unit of time\n')
             except:
                 print(f'Block {str(memory.memoryBlock())} was not allocated')
-        print(self.__totalTime)
-        print(len(self.__job))
 
 
 
 def main():
     memoryBlockList = []
     jobList = []
     
@@ -420,19 +412,16 @@ def main():
             row = line.split()
             jobList.append(JobInfo(int(row[0]), int(row[1]), int(row[2])))
 
-    while True:
-        print(f'Choose Algorithm [1] Worst Fit\t [2] Best Fit\t [3] First Fit')
-        key = input("""")
-        if key == '1':
-            wf = WorstFit(memoryBlockList, jobList).worstFit()
-        elif key == '2':
-            bf = BestFit(memoryBlockList, jobList).bestFit()
-        elif key == '3':
-            ff = FirstFit(memoryBlockList, jobList).firstFit()
-        else:
-            print(""Invalid Key. Please try again.\n"")
-    
-    
 
-main()
 "
OK;22;DeinyRhed;CMSC-123--Memory-Management-and-Allocation-Strategies;c088a95eefd69a2d9be7406e8044da991debe329;Update memory_allocation_strategies.py;"def updateTime(self):
         if self.__jobTime <= 0:
             self.__jobTime = 0
 
+     
 
 class MemoryBlock:
     def __init__(self, memoryBlock, memorySize):
@@ -48,17 +46,14 @@ def __init__(self, memory:[MemoryBlock], job:[JobInfo]):
         self.__job = job
         self.__allocation = {}  # ({memory : job})
         self.__jobCount = 0     # For the total assigned jobs
+        self.__totalTime = 140  # total time from the given jobs based on the MP3
         self.__timer = 1        # For the time
         self.__sumIF = {}       # Total Internal Fragmentation per block ({ memory : job })
         self.__sumBlock = 0  
         self.__totalHUP = {}    # Total Heavily Used Partition ({ memoryBlock : jobSize })
         self.__totalUP = {}     # Total Unused Partition ({ memoryBlock : differenceSize})
+        self.__totalWT = 0
        
     
     # This is for the internal fragmentation portion
     def sumIF(self, memory:MemoryBlock, job:JobInfo):
@@ -99,8 +94,12 @@ def firstFit(self):
                         self.__allocation.update({memory : job})
                         self.sumIF(memory,job)
                         self.__jobCount += 1
                         break
+        
+        for key,value in self.__allocation.items():
+            self.__totalWT += value.jobTime()
+            print(f'Job {str(value.jobStream())} has been allocated in memory block {str(key.memoryBlock())} and will reside for {str(value.jobTime())} ms')
+            
                     
         
         while len(tempList) -1 >= 2:
@@ -113,7 +112,6 @@ def firstFit(self):
                     job.updateTime()
                     if job.jobTime() > 0:
                         self.__jobCount += 1
                     # If time == 1, then remove it from the jobList named tempList
                     # Also remove the value from the self.__allocation dictionary
                     else:
@@ -128,18 +126,23 @@ def firstFit(self):
                                     self.__allocation.update({memory : job2})
                                     self.sumIF(memory,job2)
                                     self.__jobCount += 1
                                     break
                 else:
                     continue
+            for key,value in self.__allocation.items():
+                if value != None:
+                    self.__totalWT += value.jobTime()
+                    print(f'Job {str(value.jobStream())} has been allocated in memory block {str(key.memoryBlock())} and will reside for {str(value.jobTime())} ms')
+                    
+                    
         self.status()
             
     
     def status(self):
         print(f'\n===================================== FIRST FIT ===================================== ')
         print(f'AVERAGE THROUGHPUT (TOTAL ASSIGNED JOB COUNT/ TOTAL TIME: {str(round(self.__jobCount/self.__timer, 2))} jobs per unit of time')
         print(f'AVERAGE WAITING QUEUE (TOTAL WQ LENGTH/ TOTAL TIME: {str(round(self.__totalTime/self.__timer,2))} jobs per unit of time')
+        print(f'AVERAGE WAITING TIME (TOTAL WT/ #JOBS): {str(round(self.__totalWT/self.__jobCount,2))} jobs per unit of time\n')
         print(f'TOTAL UNUSED PARTITION ((TOTAL USED MEMORY / 50000) * 100): {str(round(((sum(self.__totalUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity')
         print(f'TOTAL HEAVILY USED PARTITION ((TOTAL EXHAUSTED MEMORY / 50000) * 100): {str(round(((sum(self.__totalHUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity\n')
         print(f'----------------------------- INTERNAL FRAGMENTATION -----------------------------')
@@ -159,20 +162,13 @@ def __init__(self, memory:[MemoryBlock], job:[JobInfo]):
         self.__job = job
         self.__allocation = {}  # ({job : memory})
         self.__jobCount = 0     # For the total assigned jobs
+        self.__totalTime = 140  # constant based on the MP3 given jobs
         self.__timer = 1        # For the timer
         self.__sumBlock = 0
         self.__sumIF = {}       # Total Internal Fragmentation per block ({ memory : diffSize })
         self.__totalHUP = {}    # Total Heavily Used Partition ({ memoryBlock : jobSize })
         self.__totalUP = {}     # Total Unused Partition ({ memoryBlock : differenceSize})
         self.__totalWT = 0
     
     
     def sumIF(self, memory:MemoryBlock, job:JobInfo):
@@ -182,7 +178,6 @@ def sumIF(self, memory:MemoryBlock, job:JobInfo):
             self.__sumIF.update({memory.memoryBlock() : [self.__sumBlock]}) # value is a list because we are storing the job and memory size difference in that block
             self.__totalHUP.update({memory.memoryBlock() : job.jobSize()})
             self.__totalUP.update({memory.memoryBlock() : self.__sumBlock})
             
         else:
             temp = (memory.memorySize() - job.jobSize())
@@ -214,7 +209,7 @@ def bestFit(self):
 
         for key,value in self.__allocation.items():
             self.__totalWT += key.jobTime()
+            print(f'Job {str(key.jobStream())} has been allocated in memory block {str(value.memoryBlock())} and will reside for {str(key.jobTime())} ms')
             self.sumIF(value,key)   # key = job and value = memory
             
         self.__jobCount += len(self.__allocation)
@@ -252,7 +247,7 @@ def bestFit(self):
 
             for key,value in self.__allocation.items():
                 self.__totalWT += key.jobTime()
+                print(f'Job {str(key.jobStream())} has been allocated in memory block {str(value.memoryBlock())} and will reside for {str(key.jobTime())} ms')
                 self.sumIF(value,key)
 
         self.status()
@@ -261,8 +256,8 @@ def bestFit(self):
     def status(self):
         print(f'\n===================================== BEST FIT ===================================== ')
         print(f'AVERAGE THROUGHPUT (TOTAL ASSIGNED JOB COUNT/ TOTAL TIME: {str(round(self.__jobCount/self.__timer, 2))} jobs per unit of time')
+        print(f'AVERAGE WAITING QUEUE (TOTAL WQ LENGTH/ TOTAL TIME: {str(round(self.__totalTime/self.__timer,2))} jobs per unit of time')
+        print(f'AVERAGE WAITING TIME (TOTAL WT/ #JOBS): {str(round((self.__totalWT)/self.__jobCount,2))} jobs per unit of time\n')
         print(f'TOTAL UNUSED PARTITION ((TOTAL USED MEMORY / 50000) * 100): {str(round(((sum(self.__totalUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity')
         print(f'TOTAL HEAVILY USED PARTITION ((TOTAL EXHAUSTED MEMORY / 50000) * 100): {str(round(((sum(self.__totalHUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity\n')
         print(f'----------------------------- INTERNAL FRAGMENTATION -----------------------------')
@@ -272,7 +267,6 @@ def status(self):
             print(f'Block {str(memory.memoryBlock())}\'s total internal fragmentation (sum[block.size - job.size]): {str((sum(self.__sumIF[memory.memoryBlock()])))} units of memory')
             print(f'Block {str(memory.memoryBlock())}\'s average internal fragmentation (sum / totalTime): {str(round(sum(self.__sumIF[memory.memoryBlock()])/self.__timer, 2 ))} units of memory per unit of time\n')
 
 
 
 # Worst Fit Memory Allocation
@@ -283,25 +277,25 @@ def __init__(self, memory:[MemoryBlock], job:[JobInfo]):
         self.__job = job
         self.__allocation = {}  # ({job : memory})
         self.__jobCount = 0     # For the total assigned jobs
+        self.__totalTime = 140  # constant given in the description of MP
         self.__timer = 1        # For the timer
         self.__sumBlock = 0
         self.__sumIF = {}       # Total Internal Fragmentation per block ({ memory : diffSize })
         self.__sumBlock = 0  
         self.__totalHUP = {}    # Total Heavily Used Partition ({ memoryBlock : jobSize })
         self.__totalUP = {}     # Total Unused Partition ({ memoryBlock : differenceSize})
         self.__totalWT = 0
+        self.__temp = job
+
+
     def sumIF(self, memory:MemoryBlock, job:JobInfo):
         self.__sumBlock = 0
         if memory.memoryBlock() not in self.__sumIF:
             self.__sumBlock = (memory.memorySize() - job.jobSize()) + self.__sumBlock
             self.__sumIF.update({memory.memoryBlock() : [self.__sumBlock]})
             self.__totalHUP.update({memory.memoryBlock() : job.jobSize()})
             self.__totalUP.update({memory.memoryBlock() : self.__sumBlock})
+
             
         else:
             temp = (memory.memorySize() - job.jobSize())
@@ -332,13 +326,12 @@ def worstFit(self):
                             worstBlock = 0
                     else:
                         worstBlock = diffSize
             
         for key,value in self.__allocation.items():
             self.__totalWT += key.jobTime()
+            self.sumIF(value,key) 
+            print(f'Job {str(key.jobStream())} has been allocated in memory block {str(value.memoryBlock())} and will reside for {str(key.jobTime())} ms')
+                   
         while len(self.__allocation) >= 1:
             if len(self.__allocation) == 1 and list(self.__allocation.keys())[0].jobTime() - 1 == 0:
                 break  
@@ -373,7 +366,7 @@ def worstFit(self):
             for key,value in self.__allocation.items():
                 self.sumIF(memory,job)
                 self.__totalWT += key.jobTime()
+                print(f'Job {str(key.jobStream())} has been allocated in memory block {str(value.memoryBlock())} and will reside for {str(key.jobTime())} ms')
             
 
         self.status()
@@ -382,8 +375,8 @@ def worstFit(self):
     def status(self):
         print(f'\n===================================== WORST FIT ===================================== ')
         print(f'AVERAGE THROUGHPUT (TOTAL ASSIGNED JOB COUNT/ TOTAL TIME: {str(round(self.__jobCount/self.__timer, 2))} jobs per unit of time')
+        print(f'AVERAGE WAITING QUEUE (TOTAL WQ LENGTH/ TOTAL TIME: {str(round(self.__totalTime/self.__timer,2))} jobs per unit of time')
+        print(f'AVERAGE WAITING TIME (TOTAL WT/ #JOBS): {str(round((self.__totalWT + self.__totalTime) /self.__jobCount,2))} jobs per unit of time')
         print(f'TOTAL UNUSED PARTITION ((TOTAL USED MEMORY / 50000) * 100): {str(round(((sum(self.__totalUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity')
         print(f'TOTAL HEAVILY USED PARTITION ((TOTAL EXHAUSTED MEMORY / 50000) * 100): {str(round(((sum(self.__totalHUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity\n')
         print(f'----------------------------- INTERNAL FRAGMENTATION -----------------------------')
@@ -395,12 +388,11 @@ def status(self):
                 print(f'Block {str(memory.memoryBlock())}\'s average internal fragmentation (sum / totalTime): {str(round(sum(self.__sumIF[memory.memoryBlock()])/self.__timer, 2 ))} units of memory per unit of time\n')
             except:
                 print(f'Block {str(memory.memoryBlock())} was not allocated')
 
 
 
 def main():
+
     memoryBlockList = []
     jobList = []
     
@@ -420,19 +412,16 @@ def main():
             row = line.split()
             jobList.append(JobInfo(int(row[0]), int(row[1]), int(row[2])))
 
 
+    print(f'Choose Algorithm [1] Worst Fit\t [2] Best Fit\t [3] First Fit')
+    key = input("""")
+    if key == '1':
+        wf = WorstFit(memoryBlockList, jobList).worstFit()
+    elif key == '2':
+        bf = BestFit(memoryBlockList, jobList).bestFit()
+    elif key == '3':
+        ff = FirstFit(memoryBlockList, jobList).firstFit()
+    else:
+        print(""Invalid Key. Please try again.\n"")
 
+main()"
KO;27;DeinyRhed;CMSC-123--Memory-Management-and-Allocation-Strategies;c088a95eefd69a2d9be7406e8044da991debe329;Update memory_allocation_strategies.py;"def updateTime(self):
         if self.__jobTime <= 0:
             self.__jobTime = 0
 
-
-
-            
 
 class MemoryBlock:
     def __init__(self, memoryBlock, memorySize):
@@ -48,17 +46,14 @@ def __init__(self, memory:[MemoryBlock], job:[JobInfo]):
         self.__job = job
         self.__allocation = {}  # ({memory : job})
         self.__jobCount = 0     # For the total assigned jobs
-        self.__totalTime = 0
         self.__timer = 1        # For the time
         self.__sumIF = {}       # Total Internal Fragmentation per block ({ memory : job })
         self.__sumBlock = 0  
         self.__totalHUP = {}    # Total Heavily Used Partition ({ memoryBlock : jobSize })
         self.__totalUP = {}     # Total Unused Partition ({ memoryBlock : differenceSize})
        
-    def totalTime(self):
-        for job in self.__job:
-            self.__totalTime += job.jobTime()
-        return self.__totalTime
     
     # This is for the internal fragmentation portion
     def sumIF(self, memory:MemoryBlock, job:JobInfo):
@@ -99,8 +94,12 @@ def firstFit(self):
                         self.__allocation.update({memory : job})
                         self.sumIF(memory,job)
                         self.__jobCount += 1
-                        print(f'Job {str(job.jobStream())}: {str(job.jobSize())} has been allocated in memory block {str(memory.memoryBlock())}:{str(memory.memorySize())} and will reside for {str(job.jobTime())} ms') 
                         break
                     
         
         while len(tempList) -1 >= 2:
@@ -113,7 +112,6 @@ def firstFit(self):
                     job.updateTime()
                     if job.jobTime() > 0:
                         self.__jobCount += 1
-                        print(f'Job {str(job.jobStream())} : {str(job.jobSize())} has been allocated in memory block {str(memory.memoryBlock())}:{str(memory.memorySize())} and will reside for {str(job.jobTime())} ms')
                     # If time == 1, then remove it from the jobList named tempList
                     # Also remove the value from the self.__allocation dictionary
                     else:
@@ -128,18 +126,23 @@ def firstFit(self):
                                     self.__allocation.update({memory : job2})
                                     self.sumIF(memory,job2)
                                     self.__jobCount += 1
-                                    print(f'Job {str(job2.jobStream())} : {str(job.jobSize())} has been allocated in memory block {str(memory.memoryBlock())}:{str(memory.memorySize())} and will reside for {str(job2.jobTime())} ms')
                                     break
                 else:
                     continue
         self.status()
             
     
     def status(self):
         print(f'\n===================================== FIRST FIT ===================================== ')
         print(f'AVERAGE THROUGHPUT (TOTAL ASSIGNED JOB COUNT/ TOTAL TIME: {str(round(self.__jobCount/self.__timer, 2))} jobs per unit of time')
         print(f'AVERAGE WAITING QUEUE (TOTAL WQ LENGTH/ TOTAL TIME: {str(round(self.__totalTime/self.__timer,2))} jobs per unit of time')
-        print(f'AVERAGE WAITING TIME (TOTAL WT/ #JOBS: {str(round(self.totalTime()/len(self.__job),2))} jobs per unit of time\n')
         print(f'TOTAL UNUSED PARTITION ((TOTAL USED MEMORY / 50000) * 100): {str(round(((sum(self.__totalUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity')
         print(f'TOTAL HEAVILY USED PARTITION ((TOTAL EXHAUSTED MEMORY / 50000) * 100): {str(round(((sum(self.__totalHUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity\n')
         print(f'----------------------------- INTERNAL FRAGMENTATION -----------------------------')
@@ -159,20 +162,13 @@ def __init__(self, memory:[MemoryBlock], job:[JobInfo]):
         self.__job = job
         self.__allocation = {}  # ({job : memory})
         self.__jobCount = 0     # For the total assigned jobs
-        self.__totalTime = 0
         self.__timer = 1        # For the timer
         self.__sumBlock = 0
         self.__sumIF = {}       # Total Internal Fragmentation per block ({ memory : diffSize })
-        self.__sumBlock = 0  
         self.__totalHUP = {}    # Total Heavily Used Partition ({ memoryBlock : jobSize })
         self.__totalUP = {}     # Total Unused Partition ({ memoryBlock : differenceSize})
         self.__totalWT = 0
-        self.__totalWQ = {}
-       
-    def totalTime(self):
-        for job in self.__job:
-            self.__totalTime += job.jobTime()
-        return self.__totalTime
     
     
     def sumIF(self, memory:MemoryBlock, job:JobInfo):
@@ -182,7 +178,6 @@ def sumIF(self, memory:MemoryBlock, job:JobInfo):
             self.__sumIF.update({memory.memoryBlock() : [self.__sumBlock]}) # value is a list because we are storing the job and memory size difference in that block
             self.__totalHUP.update({memory.memoryBlock() : job.jobSize()})
             self.__totalUP.update({memory.memoryBlock() : self.__sumBlock})
-            self.__totalWQ.update({memory.memoryBlock() : job.jobTime()})
             
         else:
             temp = (memory.memorySize() - job.jobSize())
@@ -214,7 +209,7 @@ def bestFit(self):
 
         for key,value in self.__allocation.items():
             self.__totalWT += key.jobTime()
-            print(f'Job {str(key.jobStream())}:{str(key.jobSize())} has been allocated in memory block {str(value.memoryBlock())}:{str(value.memorySize())} and will reside for {str(key.jobTime())} ms')
             self.sumIF(value,key)   # key = job and value = memory
             
         self.__jobCount += len(self.__allocation)
@@ -252,7 +247,7 @@ def bestFit(self):
 
             for key,value in self.__allocation.items():
                 self.__totalWT += key.jobTime()
-                print(f'Job {str(key.jobStream())}:{str(key.jobSize())} has been allocated in memory block {str(value.memoryBlock())}:{str(value.memorySize())} and will reside for {str(key.jobTime())} ms')
                 self.sumIF(value,key)
 
         self.status()
@@ -261,8 +256,8 @@ def bestFit(self):
     def status(self):
         print(f'\n===================================== BEST FIT ===================================== ')
         print(f'AVERAGE THROUGHPUT (TOTAL ASSIGNED JOB COUNT/ TOTAL TIME: {str(round(self.__jobCount/self.__timer, 2))} jobs per unit of time')
-        print(f'AVERAGE WAITING QUEUE (TOTAL WQ LENGTH/ TOTAL TIME: {str(self.__jobCount/self.__timer)} jobs per unit of time')
-        print(f'AVERAGE WAITING TIME (TOTAL WT/ #JOBS: {str(round(self.totalTime()/self.__timer,2))} jobs per unit of time\n')
         print(f'TOTAL UNUSED PARTITION ((TOTAL USED MEMORY / 50000) * 100): {str(round(((sum(self.__totalUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity')
         print(f'TOTAL HEAVILY USED PARTITION ((TOTAL EXHAUSTED MEMORY / 50000) * 100): {str(round(((sum(self.__totalHUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity\n')
         print(f'----------------------------- INTERNAL FRAGMENTATION -----------------------------')
@@ -272,7 +267,6 @@ def status(self):
             print(f'Block {str(memory.memoryBlock())}\'s total internal fragmentation (sum[block.size - job.size]): {str((sum(self.__sumIF[memory.memoryBlock()])))} units of memory')
             print(f'Block {str(memory.memoryBlock())}\'s average internal fragmentation (sum / totalTime): {str(round(sum(self.__sumIF[memory.memoryBlock()])/self.__timer, 2 ))} units of memory per unit of time\n')
 
-        print(self.__totalWT)
 
 
 # Worst Fit Memory Allocation
@@ -283,25 +277,25 @@ def __init__(self, memory:[MemoryBlock], job:[JobInfo]):
         self.__job = job
         self.__allocation = {}  # ({job : memory})
         self.__jobCount = 0     # For the total assigned jobs
-        self.__totalTime = len(self.__job)
         self.__timer = 1        # For the timer
         self.__sumBlock = 0
         self.__sumIF = {}       # Total Internal Fragmentation per block ({ memory : diffSize })
         self.__sumBlock = 0  
         self.__totalHUP = {}    # Total Heavily Used Partition ({ memoryBlock : jobSize })
         self.__totalUP = {}     # Total Unused Partition ({ memoryBlock : differenceSize})
         self.__totalWT = 0
-        self.__totalWQ = {}
-    
-    
     def sumIF(self, memory:MemoryBlock, job:JobInfo):
         self.__sumBlock = 0
         if memory.memoryBlock() not in self.__sumIF:
             self.__sumBlock = (memory.memorySize() - job.jobSize()) + self.__sumBlock
             self.__sumIF.update({memory.memoryBlock() : [self.__sumBlock]})
             self.__totalHUP.update({memory.memoryBlock() : job.jobSize()})
             self.__totalUP.update({memory.memoryBlock() : self.__sumBlock})
-            self.__totalWQ.update({memory.memoryBlock() : job.jobTime()})
             
         else:
             temp = (memory.memorySize() - job.jobSize())
@@ -332,13 +326,12 @@ def worstFit(self):
                             worstBlock = 0
                     else:
                         worstBlock = diffSize
-
             
         for key,value in self.__allocation.items():
             self.__totalWT += key.jobTime()
-            print(f'Job {str(key.jobStream())}:{str(key.jobSize())} has been allocated in memory block {str(value.memoryBlock())}:{str(value.memorySize())} and will reside for {str(key.jobTime())} ms')
-            self.sumIF(value,key)        
-        
         while len(self.__allocation) >= 1:
             if len(self.__allocation) == 1 and list(self.__allocation.keys())[0].jobTime() - 1 == 0:
                 break  
@@ -373,7 +366,7 @@ def worstFit(self):
             for key,value in self.__allocation.items():
                 self.sumIF(memory,job)
                 self.__totalWT += key.jobTime()
-                print(f'Job {str(key.jobStream())}:{str(key.jobSize())} has been allocated in memory block {str(value.memoryBlock())}:{str(value.memorySize())} and will reside for {str(key.jobTime())} ms')
             
 
         self.status()
@@ -382,8 +375,8 @@ def worstFit(self):
     def status(self):
         print(f'\n===================================== WORST FIT ===================================== ')
         print(f'AVERAGE THROUGHPUT (TOTAL ASSIGNED JOB COUNT/ TOTAL TIME: {str(round(self.__jobCount/self.__timer, 2))} jobs per unit of time')
-        print(f'AVERAGE WAITING QUEUE (TOTAL WQ LENGTH/ TOTAL TIME: {str(round(self.totalTime()/self.__timer,2))} jobs per unit of time')
-        print(f'AVERAGE WAITING TIME (TOTAL WT/ #JOBS): {str(round(self.totalTime()/len(self.__job),2))} jobs per unit of time')
         print(f'TOTAL UNUSED PARTITION ((TOTAL USED MEMORY / 50000) * 100): {str(round(((sum(self.__totalUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity')
         print(f'TOTAL HEAVILY USED PARTITION ((TOTAL EXHAUSTED MEMORY / 50000) * 100): {str(round(((sum(self.__totalHUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity\n')
         print(f'----------------------------- INTERNAL FRAGMENTATION -----------------------------')
@@ -395,12 +388,11 @@ def status(self):
                 print(f'Block {str(memory.memoryBlock())}\'s average internal fragmentation (sum / totalTime): {str(round(sum(self.__sumIF[memory.memoryBlock()])/self.__timer, 2 ))} units of memory per unit of time\n')
             except:
                 print(f'Block {str(memory.memoryBlock())} was not allocated')
-        print(self.__totalTime)
-        print(len(self.__job))
 
 
 
 def main():
     memoryBlockList = []
     jobList = []
     
@@ -420,19 +412,16 @@ def main():
             row = line.split()
             jobList.append(JobInfo(int(row[0]), int(row[1]), int(row[2])))
 
-    while True:
-        print(f'Choose Algorithm [1] Worst Fit\t [2] Best Fit\t [3] First Fit')
-        key = input("""")
-        if key == '1':
-            wf = WorstFit(memoryBlockList, jobList).worstFit()
-        elif key == '2':
-            bf = BestFit(memoryBlockList, jobList).bestFit()
-        elif key == '3':
-            ff = FirstFit(memoryBlockList, jobList).firstFit()
-        else:
-            print(""Invalid Key. Please try again.\n"")
-    
-    
 
-main()
 "
OK;27;DeinyRhed;CMSC-123--Memory-Management-and-Allocation-Strategies;c088a95eefd69a2d9be7406e8044da991debe329;Update memory_allocation_strategies.py;"def updateTime(self):
         if self.__jobTime <= 0:
             self.__jobTime = 0
 
+     
 
 class MemoryBlock:
     def __init__(self, memoryBlock, memorySize):
@@ -48,17 +46,14 @@ def __init__(self, memory:[MemoryBlock], job:[JobInfo]):
         self.__job = job
         self.__allocation = {}  # ({memory : job})
         self.__jobCount = 0     # For the total assigned jobs
+        self.__totalTime = 140  # total time from the given jobs based on the MP3
         self.__timer = 1        # For the time
         self.__sumIF = {}       # Total Internal Fragmentation per block ({ memory : job })
         self.__sumBlock = 0  
         self.__totalHUP = {}    # Total Heavily Used Partition ({ memoryBlock : jobSize })
         self.__totalUP = {}     # Total Unused Partition ({ memoryBlock : differenceSize})
+        self.__totalWT = 0
        
     
     # This is for the internal fragmentation portion
     def sumIF(self, memory:MemoryBlock, job:JobInfo):
@@ -99,8 +94,12 @@ def firstFit(self):
                         self.__allocation.update({memory : job})
                         self.sumIF(memory,job)
                         self.__jobCount += 1
                         break
+        
+        for key,value in self.__allocation.items():
+            self.__totalWT += value.jobTime()
+            print(f'Job {str(value.jobStream())} has been allocated in memory block {str(key.memoryBlock())} and will reside for {str(value.jobTime())} ms')
+            
                     
         
         while len(tempList) -1 >= 2:
@@ -113,7 +112,6 @@ def firstFit(self):
                     job.updateTime()
                     if job.jobTime() > 0:
                         self.__jobCount += 1
                     # If time == 1, then remove it from the jobList named tempList
                     # Also remove the value from the self.__allocation dictionary
                     else:
@@ -128,18 +126,23 @@ def firstFit(self):
                                     self.__allocation.update({memory : job2})
                                     self.sumIF(memory,job2)
                                     self.__jobCount += 1
                                     break
                 else:
                     continue
+            for key,value in self.__allocation.items():
+                if value != None:
+                    self.__totalWT += value.jobTime()
+                    print(f'Job {str(value.jobStream())} has been allocated in memory block {str(key.memoryBlock())} and will reside for {str(value.jobTime())} ms')
+                    
+                    
         self.status()
             
     
     def status(self):
         print(f'\n===================================== FIRST FIT ===================================== ')
         print(f'AVERAGE THROUGHPUT (TOTAL ASSIGNED JOB COUNT/ TOTAL TIME: {str(round(self.__jobCount/self.__timer, 2))} jobs per unit of time')
         print(f'AVERAGE WAITING QUEUE (TOTAL WQ LENGTH/ TOTAL TIME: {str(round(self.__totalTime/self.__timer,2))} jobs per unit of time')
+        print(f'AVERAGE WAITING TIME (TOTAL WT/ #JOBS): {str(round(self.__totalWT/self.__jobCount,2))} jobs per unit of time\n')
         print(f'TOTAL UNUSED PARTITION ((TOTAL USED MEMORY / 50000) * 100): {str(round(((sum(self.__totalUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity')
         print(f'TOTAL HEAVILY USED PARTITION ((TOTAL EXHAUSTED MEMORY / 50000) * 100): {str(round(((sum(self.__totalHUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity\n')
         print(f'----------------------------- INTERNAL FRAGMENTATION -----------------------------')
@@ -159,20 +162,13 @@ def __init__(self, memory:[MemoryBlock], job:[JobInfo]):
         self.__job = job
         self.__allocation = {}  # ({job : memory})
         self.__jobCount = 0     # For the total assigned jobs
+        self.__totalTime = 140  # constant based on the MP3 given jobs
         self.__timer = 1        # For the timer
         self.__sumBlock = 0
         self.__sumIF = {}       # Total Internal Fragmentation per block ({ memory : diffSize })
         self.__totalHUP = {}    # Total Heavily Used Partition ({ memoryBlock : jobSize })
         self.__totalUP = {}     # Total Unused Partition ({ memoryBlock : differenceSize})
         self.__totalWT = 0
     
     
     def sumIF(self, memory:MemoryBlock, job:JobInfo):
@@ -182,7 +178,6 @@ def sumIF(self, memory:MemoryBlock, job:JobInfo):
             self.__sumIF.update({memory.memoryBlock() : [self.__sumBlock]}) # value is a list because we are storing the job and memory size difference in that block
             self.__totalHUP.update({memory.memoryBlock() : job.jobSize()})
             self.__totalUP.update({memory.memoryBlock() : self.__sumBlock})
             
         else:
             temp = (memory.memorySize() - job.jobSize())
@@ -214,7 +209,7 @@ def bestFit(self):
 
         for key,value in self.__allocation.items():
             self.__totalWT += key.jobTime()
+            print(f'Job {str(key.jobStream())} has been allocated in memory block {str(value.memoryBlock())} and will reside for {str(key.jobTime())} ms')
             self.sumIF(value,key)   # key = job and value = memory
             
         self.__jobCount += len(self.__allocation)
@@ -252,7 +247,7 @@ def bestFit(self):
 
             for key,value in self.__allocation.items():
                 self.__totalWT += key.jobTime()
+                print(f'Job {str(key.jobStream())} has been allocated in memory block {str(value.memoryBlock())} and will reside for {str(key.jobTime())} ms')
                 self.sumIF(value,key)
 
         self.status()
@@ -261,8 +256,8 @@ def bestFit(self):
     def status(self):
         print(f'\n===================================== BEST FIT ===================================== ')
         print(f'AVERAGE THROUGHPUT (TOTAL ASSIGNED JOB COUNT/ TOTAL TIME: {str(round(self.__jobCount/self.__timer, 2))} jobs per unit of time')
+        print(f'AVERAGE WAITING QUEUE (TOTAL WQ LENGTH/ TOTAL TIME: {str(round(self.__totalTime/self.__timer,2))} jobs per unit of time')
+        print(f'AVERAGE WAITING TIME (TOTAL WT/ #JOBS): {str(round((self.__totalWT)/self.__jobCount,2))} jobs per unit of time\n')
         print(f'TOTAL UNUSED PARTITION ((TOTAL USED MEMORY / 50000) * 100): {str(round(((sum(self.__totalUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity')
         print(f'TOTAL HEAVILY USED PARTITION ((TOTAL EXHAUSTED MEMORY / 50000) * 100): {str(round(((sum(self.__totalHUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity\n')
         print(f'----------------------------- INTERNAL FRAGMENTATION -----------------------------')
@@ -272,7 +267,6 @@ def status(self):
             print(f'Block {str(memory.memoryBlock())}\'s total internal fragmentation (sum[block.size - job.size]): {str((sum(self.__sumIF[memory.memoryBlock()])))} units of memory')
             print(f'Block {str(memory.memoryBlock())}\'s average internal fragmentation (sum / totalTime): {str(round(sum(self.__sumIF[memory.memoryBlock()])/self.__timer, 2 ))} units of memory per unit of time\n')
 
 
 
 # Worst Fit Memory Allocation
@@ -283,25 +277,25 @@ def __init__(self, memory:[MemoryBlock], job:[JobInfo]):
         self.__job = job
         self.__allocation = {}  # ({job : memory})
         self.__jobCount = 0     # For the total assigned jobs
+        self.__totalTime = 140  # constant given in the description of MP
         self.__timer = 1        # For the timer
         self.__sumBlock = 0
         self.__sumIF = {}       # Total Internal Fragmentation per block ({ memory : diffSize })
         self.__sumBlock = 0  
         self.__totalHUP = {}    # Total Heavily Used Partition ({ memoryBlock : jobSize })
         self.__totalUP = {}     # Total Unused Partition ({ memoryBlock : differenceSize})
         self.__totalWT = 0
+        self.__temp = job
+
+
     def sumIF(self, memory:MemoryBlock, job:JobInfo):
         self.__sumBlock = 0
         if memory.memoryBlock() not in self.__sumIF:
             self.__sumBlock = (memory.memorySize() - job.jobSize()) + self.__sumBlock
             self.__sumIF.update({memory.memoryBlock() : [self.__sumBlock]})
             self.__totalHUP.update({memory.memoryBlock() : job.jobSize()})
             self.__totalUP.update({memory.memoryBlock() : self.__sumBlock})
+
             
         else:
             temp = (memory.memorySize() - job.jobSize())
@@ -332,13 +326,12 @@ def worstFit(self):
                             worstBlock = 0
                     else:
                         worstBlock = diffSize
             
         for key,value in self.__allocation.items():
             self.__totalWT += key.jobTime()
+            self.sumIF(value,key) 
+            print(f'Job {str(key.jobStream())} has been allocated in memory block {str(value.memoryBlock())} and will reside for {str(key.jobTime())} ms')
+                   
         while len(self.__allocation) >= 1:
             if len(self.__allocation) == 1 and list(self.__allocation.keys())[0].jobTime() - 1 == 0:
                 break  
@@ -373,7 +366,7 @@ def worstFit(self):
             for key,value in self.__allocation.items():
                 self.sumIF(memory,job)
                 self.__totalWT += key.jobTime()
+                print(f'Job {str(key.jobStream())} has been allocated in memory block {str(value.memoryBlock())} and will reside for {str(key.jobTime())} ms')
             
 
         self.status()
@@ -382,8 +375,8 @@ def worstFit(self):
     def status(self):
         print(f'\n===================================== WORST FIT ===================================== ')
         print(f'AVERAGE THROUGHPUT (TOTAL ASSIGNED JOB COUNT/ TOTAL TIME: {str(round(self.__jobCount/self.__timer, 2))} jobs per unit of time')
+        print(f'AVERAGE WAITING QUEUE (TOTAL WQ LENGTH/ TOTAL TIME: {str(round(self.__totalTime/self.__timer,2))} jobs per unit of time')
+        print(f'AVERAGE WAITING TIME (TOTAL WT/ #JOBS): {str(round((self.__totalWT + self.__totalTime) /self.__jobCount,2))} jobs per unit of time')
         print(f'TOTAL UNUSED PARTITION ((TOTAL USED MEMORY / 50000) * 100): {str(round(((sum(self.__totalUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity')
         print(f'TOTAL HEAVILY USED PARTITION ((TOTAL EXHAUSTED MEMORY / 50000) * 100): {str(round(((sum(self.__totalHUP.values()))/50000)*100, 2))}% out of 50,000 memory capacity\n')
         print(f'----------------------------- INTERNAL FRAGMENTATION -----------------------------')
@@ -395,12 +388,11 @@ def status(self):
                 print(f'Block {str(memory.memoryBlock())}\'s average internal fragmentation (sum / totalTime): {str(round(sum(self.__sumIF[memory.memoryBlock()])/self.__timer, 2 ))} units of memory per unit of time\n')
             except:
                 print(f'Block {str(memory.memoryBlock())} was not allocated')
 
 
 
 def main():
+
     memoryBlockList = []
     jobList = []
     
@@ -420,19 +412,16 @@ def main():
             row = line.split()
             jobList.append(JobInfo(int(row[0]), int(row[1]), int(row[2])))
 
 
+    print(f'Choose Algorithm [1] Worst Fit\t [2] Best Fit\t [3] First Fit')
+    key = input("""")
+    if key == '1':
+        wf = WorstFit(memoryBlockList, jobList).worstFit()
+    elif key == '2':
+        bf = BestFit(memoryBlockList, jobList).bestFit()
+    elif key == '3':
+        ff = FirstFit(memoryBlockList, jobList).firstFit()
+    else:
+        print(""Invalid Key. Please try again.\n"")
 
+main()"
KO;43;vanegascata;GAN;dec28e3dd38ec52c02c8fb3e4e8c4baf216555cf;fixed bug with pandas sampling frac -  decrease memory usage. Fixes for issue #14;"def preprocess_data(self, train_df, target, test_df, ) -> Tuple[pd.DataFrame, pd
     def generate_data(self, train_df, target, test_df) -> Tuple[pd.DataFrame, pd.DataFrame]:
         self._validate_data(train_df, target, test_df)
         train_df[self.TEMP_TARGET] = target
-        generated_df = train_df.sample(frac=(1 + self.pregeneration_frac * self.get_generated_shape(train_df)),
-                                       replace=True, random_state=42)
         generated_df = generated_df.reset_index(drop=True)
         gc.collect()
         return generated_df.drop(self.TEMP_TARGET, axis=1), generated_df[self.TEMP_TARGET]
@@ -135,6 +134,7 @@ def adversarial_filtering(self, train_df, target, test_df, ):
         train_df[""test_similarity""] = ad_model.trained_model.predict(train_df.drop(self.TEMP_TARGET, axis=1))
         train_df.sort_values(""test_similarity"", ascending=False, inplace=True)
         train_df = train_df.head(self.get_generated_shape(train_df) * train_df.shape[0])
         gc.collect()
         return train_df.drop([""test_similarity"", self.TEMP_TARGET], axis=1).reset_index(drop=True), \
                train_df[self.TEMP_TARGET].reset_index(drop=True)"
OK;43;vanegascata;GAN;dec28e3dd38ec52c02c8fb3e4e8c4baf216555cf;fixed bug with pandas sampling frac -  decrease memory usage. Fixes for issue #14;"def preprocess_data(self, train_df, target, test_df, ) -> Tuple[pd.DataFrame, pd
     def generate_data(self, train_df, target, test_df) -> Tuple[pd.DataFrame, pd.DataFrame]:
         self._validate_data(train_df, target, test_df)
         train_df[self.TEMP_TARGET] = target
+        generated_df = train_df.sample(frac=(1 + self.pregeneration_frac), replace=True, random_state=42)
         generated_df = generated_df.reset_index(drop=True)
         gc.collect()
         return generated_df.drop(self.TEMP_TARGET, axis=1), generated_df[self.TEMP_TARGET]
@@ -135,6 +134,7 @@ def adversarial_filtering(self, train_df, target, test_df, ):
         train_df[""test_similarity""] = ad_model.trained_model.predict(train_df.drop(self.TEMP_TARGET, axis=1))
         train_df.sort_values(""test_similarity"", ascending=False, inplace=True)
         train_df = train_df.head(self.get_generated_shape(train_df) * train_df.shape[0])
+        del ad_model
         gc.collect()
         return train_df.drop([""test_similarity"", self.TEMP_TARGET], axis=1).reset_index(drop=True), \
                train_df[self.TEMP_TARGET].reset_index(drop=True)"
KO;43;vanegascata;GAN;acceaecc3ab376df4340cc3e1cb1324cc8884dc9;Added gc.collect after method calls - should decrease memory usage. Fixes for issue #14;" todo write description
 """"""
 
 import logging
 import warnings
 from typing import Tuple
@@ -99,6 +100,7 @@ def generate_data(self, train_df, target, test_df) -> Tuple[pd.DataFrame, pd.Dat
         generated_df = train_df.sample(frac=(1 + self.pregeneration_frac * self.get_generated_shape(train_df)),
                                        replace=True, random_state=42)
         generated_df = generated_df.reset_index(drop=True)
         return generated_df.drop(self.TEMP_TARGET, axis=1), generated_df[self.TEMP_TARGET]
 
     def postprocess_data(self, train_df, target, test_df, ):
@@ -119,6 +121,7 @@ def postprocess_data(self, train_df, target, test_df, ):
             for cat_col in self.cat_cols:
                 filtered_df = train_df[train_df[cat_col].isin(test_df[cat_col].unique())]
                 train_df = filtered_df
         return train_df.drop(self.TEMP_TARGET, axis=1).reset_index(drop=True), train_df[self.TEMP_TARGET].reset_index(
             drop=True)
 
@@ -132,6 +135,7 @@ def adversarial_filtering(self, train_df, target, test_df, ):
         train_df[""test_similarity""] = ad_model.trained_model.predict(train_df.drop(self.TEMP_TARGET, axis=1))
         train_df.sort_values(""test_similarity"", ascending=False, inplace=True)
         train_df = train_df.head(self.get_generated_shape(train_df) * train_df.shape[0])
         return train_df.drop([""test_similarity"", self.TEMP_TARGET], axis=1).reset_index(drop=True), \
                train_df[self.TEMP_TARGET].reset_index(drop=True)
 
@@ -162,14 +166,15 @@ def generate_data(self, train_df, target, test_df) -> Tuple[pd.DataFrame, pd.Dat
             ].astype(data_dtype[i])
 
         train_df = pd.concat([train_df, generated_df, ]).reset_index(drop=True)
         return train_df.drop(self.TEMP_TARGET, axis=1), train_df[self.TEMP_TARGET]
 
 
 def _sampler(creator: SampleData, in_train, in_target, in_test) -> None:
     _logger = logging.getLogger(__name__)
     _logger.info(""Starting generating data:"")
     _logger.info(creator.generate_data_pipe(in_train, in_target, in_test))
-    _logger.info(""Finished generatation\n"")
 
 
 if __name__ == ""__main__"":"
OK;43;vanegascata;GAN;acceaecc3ab376df4340cc3e1cb1324cc8884dc9;Added gc.collect after method calls - should decrease memory usage. Fixes for issue #14;" todo write description
 """"""
 
+import gc
 import logging
 import warnings
 from typing import Tuple
@@ -99,6 +100,7 @@ def generate_data(self, train_df, target, test_df) -> Tuple[pd.DataFrame, pd.Dat
         generated_df = train_df.sample(frac=(1 + self.pregeneration_frac * self.get_generated_shape(train_df)),
                                        replace=True, random_state=42)
         generated_df = generated_df.reset_index(drop=True)
+        gc.collect()
         return generated_df.drop(self.TEMP_TARGET, axis=1), generated_df[self.TEMP_TARGET]
 
     def postprocess_data(self, train_df, target, test_df, ):
@@ -119,6 +121,7 @@ def postprocess_data(self, train_df, target, test_df, ):
             for cat_col in self.cat_cols:
                 filtered_df = train_df[train_df[cat_col].isin(test_df[cat_col].unique())]
                 train_df = filtered_df
+        gc.collect()
         return train_df.drop(self.TEMP_TARGET, axis=1).reset_index(drop=True), train_df[self.TEMP_TARGET].reset_index(
             drop=True)
 
@@ -132,6 +135,7 @@ def adversarial_filtering(self, train_df, target, test_df, ):
         train_df[""test_similarity""] = ad_model.trained_model.predict(train_df.drop(self.TEMP_TARGET, axis=1))
         train_df.sort_values(""test_similarity"", ascending=False, inplace=True)
         train_df = train_df.head(self.get_generated_shape(train_df) * train_df.shape[0])
+        gc.collect()
         return train_df.drop([""test_similarity"", self.TEMP_TARGET], axis=1).reset_index(drop=True), \
                train_df[self.TEMP_TARGET].reset_index(drop=True)
 
@@ -162,14 +166,15 @@ def generate_data(self, train_df, target, test_df) -> Tuple[pd.DataFrame, pd.Dat
             ].astype(data_dtype[i])
 
         train_df = pd.concat([train_df, generated_df, ]).reset_index(drop=True)
+        gc.collect()
         return train_df.drop(self.TEMP_TARGET, axis=1), train_df[self.TEMP_TARGET]
 
 
 def _sampler(creator: SampleData, in_train, in_target, in_test) -> None:
     _logger = logging.getLogger(__name__)
     _logger.info(""Starting generating data:"")
     _logger.info(creator.generate_data_pipe(in_train, in_target, in_test))
+    _logger.info(""Finished generation\n"")
 
 
 if __name__ == ""__main__"":"
KO;43;vanegascata;GAN;acceaecc3ab376df4340cc3e1cb1324cc8884dc9;Added gc.collect after method calls - should decrease memory usage. Fixes for issue #14;"def test_postprocess_data(self):
         new_train, new_target = self.sampler.postprocess_data(gen_train, gen_target, test_df)
         self.assertEqual(new_train.shape[0], new_target.shape[0])
         self.assertGreaterEqual(new_train.iloc[:, 0].min(), test_df.iloc[:, 0].min())
 
     def test_adversarial_filtering(self):
         new_train, new_target, test_df = self.sampler.preprocess_data(self.train.copy(),"
OK;43;vanegascata;GAN;acceaecc3ab376df4340cc3e1cb1324cc8884dc9;Added gc.collect after method calls - should decrease memory usage. Fixes for issue #14;"def test_postprocess_data(self):
         new_train, new_target = self.sampler.postprocess_data(gen_train, gen_target, test_df)
         self.assertEqual(new_train.shape[0], new_target.shape[0])
         self.assertGreaterEqual(new_train.iloc[:, 0].min(), test_df.iloc[:, 0].min())
+        self.assertGreaterEqual(test_df.iloc[:, 0].max(), new_train.iloc[:, 0].max())
 
     def test_adversarial_filtering(self):
         new_train, new_target, test_df = self.sampler.preprocess_data(self.train.copy(),"
